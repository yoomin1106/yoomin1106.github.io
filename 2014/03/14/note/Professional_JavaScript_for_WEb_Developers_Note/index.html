
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>Javascript高级程序设计笔记 | matt&#39;s blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Matt.Wu">
    

    
    <meta name="description" content="一、简介
#####【ECMAScript】

一个完整的javascript实现应该由三部分构成：核心（ECMAScript）、文档(DOM)、浏览器对象模型(BOM)。
常见的web浏览器只是ECMAScript实现可能的宿主环境之一，javascript实现了ECMAScript，ActionScript同样也实现了ECMAScript。

#####【DOM和BOM】

DOM并不只是针对">
<meta property="og:type" content="article">
<meta property="og:title" content="Javascript高级程序设计笔记">
<meta property="og:url" content="http://yoomin1106.github.io/2014/03/14/note/Professional_JavaScript_for_WEb_Developers_Note/index.html">
<meta property="og:site_name" content="matt's blog">
<meta property="og:description" content="一、简介
#####【ECMAScript】

一个完整的javascript实现应该由三部分构成：核心（ECMAScript）、文档(DOM)、浏览器对象模型(BOM)。
常见的web浏览器只是ECMAScript实现可能的宿主环境之一，javascript实现了ECMAScript，ActionScript同样也实现了ECMAScript。

#####【DOM和BOM】

DOM并不只是针对">
<meta property="og:updated_time" content="2016-01-10T05:17:54.846Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Javascript高级程序设计笔记">
<meta name="twitter:description" content="一、简介
#####【ECMAScript】

一个完整的javascript实现应该由三部分构成：核心（ECMAScript）、文档(DOM)、浏览器对象模型(BOM)。
常见的web浏览器只是ECMAScript实现可能的宿主环境之一，javascript实现了ECMAScript，ActionScript同样也实现了ECMAScript。

#####【DOM和BOM】

DOM并不只是针对">

    
    <link rel="alternative" href="/atom.xml" title="matt&#39;s blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="matt&#39;s blog" title="matt&#39;s blog"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="matt&#39;s blog">matt&#39;s blog</a></h1>
				<h2 class="blog-motto">Write to remember!</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
						<li><a href="/excercise">Excercise</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:yoomin1106.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/03/14/note/Professional_JavaScript_for_WEb_Developers_Note/" title="Javascript高级程序设计笔记" itemprop="url">Javascript高级程序设计笔记</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Matt.Wu" target="_blank" itemprop="author">Matt.Wu</a>
		
  <p class="article-time">
    <time datetime="2014-03-13T16:00:00.000Z" itemprop="datePublished"> 发表于 2014-03-14</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#一、简介"><span class="toc-number">1.</span> <span class="toc-text">一、简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二、在HTML中使用javascript"><span class="toc-number">2.</span> <span class="toc-text">二、在HTML中使用javascript</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#【script】"><span class="toc-number">2.1.</span> <span class="toc-text">【script】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【文档模式】"><span class="toc-number">2.2.</span> <span class="toc-text">【文档模式】</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#三、基本概念"><span class="toc-number">3.</span> <span class="toc-text">三、基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#【语法】"><span class="toc-number">3.1.</span> <span class="toc-text">【语法】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【变量】"><span class="toc-number">3.2.</span> <span class="toc-text">【变量】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【数据类型】"><span class="toc-number">3.3.</span> <span class="toc-text">【数据类型】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【函数】"><span class="toc-number">3.4.</span> <span class="toc-text">【函数】</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#四、变量、作用域和内存问题"><span class="toc-number">4.</span> <span class="toc-text">四、变量、作用域和内存问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#【4-1基本类型和引用类型的值】"><span class="toc-number">4.1.</span> <span class="toc-text">【4.1基本类型和引用类型的值】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【4-2执行环境及作用域】"><span class="toc-number">4.2.</span> <span class="toc-text">【4.2执行环境及作用域】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【4-3垃圾收集】"><span class="toc-number">4.3.</span> <span class="toc-text">【4.3垃圾收集】</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#五、引用类型"><span class="toc-number">5.</span> <span class="toc-text">五、引用类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#【5-1-Object类型】"><span class="toc-number">5.1.</span> <span class="toc-text">【5.1 Object类型】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【5-2-Array类型】"><span class="toc-number">5.2.</span> <span class="toc-text">【5.2 Array类型】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【5-3-Date类型】"><span class="toc-number">5.3.</span> <span class="toc-text">【5.3 Date类型】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【5-4-RegExp类型】？？？？？？？？？？？？"><span class="toc-number">5.4.</span> <span class="toc-text">【5.4 RegExp类型】？？？？？？？？？？？？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【5-5-Function类型】"><span class="toc-number">5.5.</span> <span class="toc-text">【5.5 Function类型】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【5-6-基本包装类型】"><span class="toc-number">5.6.</span> <span class="toc-text">【5.6 基本包装类型】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【单体内置对象】"><span class="toc-number">5.7.</span> <span class="toc-text">【单体内置对象】</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#六、面向对象的程序设计"><span class="toc-number">6.</span> <span class="toc-text">六、面向对象的程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#【理解对象】"><span class="toc-number">6.1.</span> <span class="toc-text">【理解对象】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【6-2-创建对象】"><span class="toc-number">6.2.</span> <span class="toc-text">【6.2 创建对象】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【6-3-继承】"><span class="toc-number">6.3.</span> <span class="toc-text">【6.3 继承】</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#七、函数表达式"><span class="toc-number">7.</span> <span class="toc-text">七、函数表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#【7-1递归】"><span class="toc-number">7.1.</span> <span class="toc-text">【7.1递归】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【7-2闭包】"><span class="toc-number">7.2.</span> <span class="toc-text">【7.2闭包】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【7-3模仿块级作用域】"><span class="toc-number">7.3.</span> <span class="toc-text">【7.3模仿块级作用域】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【7-4私有变量】"><span class="toc-number">7.4.</span> <span class="toc-text">【7.4私有变量】</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#八、BOM"><span class="toc-number">8.</span> <span class="toc-text">八、BOM</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#【8-1-window对象】"><span class="toc-number">8.1.</span> <span class="toc-text">【8.1 window对象】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-2-location对象】"><span class="toc-number">8.2.</span> <span class="toc-text">8.2 location对象】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【8-3-navigation对象】"><span class="toc-number">8.3.</span> <span class="toc-text">【8.3 navigation对象】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【8-4screen对象】"><span class="toc-number">8.4.</span> <span class="toc-text">【8.4screen对象】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【8-5-history对象】"><span class="toc-number">8.5.</span> <span class="toc-text">【8.5 history对象】</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#九、客户端检测"><span class="toc-number">9.</span> <span class="toc-text">九、客户端检测</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#【9-1-能力检测】"><span class="toc-number">9.1.</span> <span class="toc-text">【9.1 能力检测】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【9-2-怪僻检测】"><span class="toc-number">9.2.</span> <span class="toc-text">【9.2 怪僻检测】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【9-3-用户代理检测】"><span class="toc-number">9.3.</span> <span class="toc-text">【9.3 用户代理检测】</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#十、DOM"><span class="toc-number">10.</span> <span class="toc-text">十、DOM</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#【10-1-节点层次】"><span class="toc-number">10.1.</span> <span class="toc-text">【10.1 节点层次】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【10-2-DOM操作技术】"><span class="toc-number">10.2.</span> <span class="toc-text">【10.2 DOM操作技术】</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#十一、DOM扩展"><span class="toc-number">11.</span> <span class="toc-text">十一、DOM扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#【11-1-选择符API】"><span class="toc-number">11.1.</span> <span class="toc-text">【11.1 选择符API】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【元素遍历】"><span class="toc-number">11.2.</span> <span class="toc-text">【元素遍历】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【11-3-HTML5】跳过"><span class="toc-number">11.3.</span> <span class="toc-text">【11.3 HTML5】跳过</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【专有扩展】"><span class="toc-number">11.4.</span> <span class="toc-text">【专有扩展】</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#十二、DOM2和DOM3"><span class="toc-number">12.</span> <span class="toc-text">十二、DOM2和DOM3</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#【12-1-DOM变化】"><span class="toc-number">12.1.</span> <span class="toc-text">【12.1 DOM变化】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【12-2-样式】"><span class="toc-number">12.2.</span> <span class="toc-text">【12.2 样式】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【12-3-遍历、12-3-范围】暂跳过"><span class="toc-number">12.3.</span> <span class="toc-text">【12.3 遍历、12.3 范围】暂跳过</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#十三、事件"><span class="toc-number">13.</span> <span class="toc-text">十三、事件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#【13-1-事件流】"><span class="toc-number">13.1.</span> <span class="toc-text">【13.1 事件流】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【13-2-事件处理程序】"><span class="toc-number">13.2.</span> <span class="toc-text">【13.2 事件处理程序】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【13-3-事件对象】"><span class="toc-number">13.3.</span> <span class="toc-text">【13.3 事件对象】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【13-4-事件类型】"><span class="toc-number">13.4.</span> <span class="toc-text">【13.4 事件类型】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【13-5-内存和性能】"><span class="toc-number">13.5.</span> <span class="toc-text">【13.5 内存和性能】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【13-6-模拟事件】"><span class="toc-number">13.6.</span> <span class="toc-text">【13.6 模拟事件】</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#十四、表单脚本"><span class="toc-number">14.</span> <span class="toc-text">十四、表单脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#【14-1-表单基础】"><span class="toc-number">14.1.</span> <span class="toc-text">【14.1 表单基础】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【14-2-文本框脚本】"><span class="toc-number">14.2.</span> <span class="toc-text">【14.2 文本框脚本】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【14-3-选择框脚本】"><span class="toc-number">14.3.</span> <span class="toc-text">【14.3 选择框脚本】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【14-4-序列化表单】-见P436"><span class="toc-number">14.4.</span> <span class="toc-text">【14.4 序列化表单】 见P436</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【14-5-富文本编辑】"><span class="toc-number">14.5.</span> <span class="toc-text">【14.5 富文本编辑】</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#十五、使用Canvas绘图"><span class="toc-number">15.</span> <span class="toc-text">十五、使用Canvas绘图</span></a></li></ol>
		
		</div>
		
		<h4 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h4><hr>
<p>#####【ECMAScript】</p>
<ul>
<li>一个完整的javascript实现应该由三部分构成：核心（ECMAScript）、文档(DOM)、浏览器对象模型(BOM)。</li>
<li>常见的web浏览器只是ECMAScript实现可能的宿主环境之一，javascript实现了ECMAScript，ActionScript同样也实现了ECMAScript。</li>
</ul>
<p>#####【DOM和BOM】</p>
<ul>
<li>DOM并不只是针对JavaScript的，很多别的语言也都实现了DOM。</li>
<li>BOM指浏览器对象模型，用于处理浏览器窗口和框架，HTML5致力于把BOM规范化。</li>
</ul>
<h4 id="二、在HTML中使用javascript"><a href="#二、在HTML中使用javascript" class="headerlink" title="二、在HTML中使用javascript"></a>二、在HTML中使用javascript</h4><hr>
<h5 id="【script】"><a href="#【script】" class="headerlink" title="【script】"></a>【script】</h5><p><strong>script简介</strong></p>
<ul>
<li>type属性可看成是language的替代属性，表示使用的脚本语言的内容类型，也称MIME类型，此属性也可忽略，通常为text/javascript，但服务器在传送javascript文件时通常用的MIME类型是application/x-javascript,但这样设置可能导致脚本被忽略。</li>
<li><code>&lt;script&gt;</code>标签对中不能出现<code>&lt;/script&gt;</code>,否则会产生错误，可通过转义解决。</li>
<li><p>插入脚本时，使用<code>&lt;script type=&quot;text/javascript&quot; src=&quot;jquery.js&quot;&gt;&lt;/script&gt;</code>，在XHTML文档中可省略<code>&lt;/script&gt;</code>，用<code>/&gt;</code>结束，为保证兼容性建议使用标签对。</p>
</li>
<li><p>外部的javascript文件带有.js扩展名，但此扩展名不是必须的，因为浏览器不会检查包含js文件的扩展名，但必须确保服务器能返回正确的MIME类型。</p>
</li>
<li><p>引入外部文件的<code>&lt;script&gt;</code>标签对中的任何脚本代码会被忽略，如</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"jquery.js"</span>&gt;alert(<span class="string">'yoomin'</span>);<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span>    <span class="comment">//其中的alert会被忽略</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> defer=<span class="string">"defer"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span>  <span class="comment">//脚本延迟到页面解析完再运行，defer只适用于外部脚本</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> <span class="keyword">async</span>=<span class="string">"async"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span>  <span class="comment">//立即下载脚本，引入多个脚本时不一定按顺序执行，但会在load事件前执行同样只适用于外部脚本</span></span><br></pre></td></tr></table></figure>
<h5 id="【文档模式】"><a href="#【文档模式】" class="headerlink" title="【文档模式】"></a>【文档模式】</h5><ul>
<li><p>混杂模式(quirks mode)会让IE的行为与包含非标准特性的IE5相同</p>
</li>
<li><p>以下表示开启标准模式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">HTML 4.01 严格型</span><br><span class="line">XHTML1.0 严格型</span><br><span class="line"><span class="comment">&lt;!-- HTML5 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>准标准模式（与标准模式几乎一样），过渡型(transitional)或框架集型(frameset)文档类型可开启</p>
</li>
</ul>
<h4 id="三、基本概念"><a href="#三、基本概念" class="headerlink" title="三、基本概念"></a>三、基本概念</h4><hr>
<h5 id="【语法】"><a href="#【语法】" class="headerlink" title="【语法】"></a>【语法】</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;              <span class="comment">//表示使用严格模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;<span class="string">"use strict"</span>; alert(<span class="string">'使用严格模式'</span>);&#125;    <span class="comment">//指定函数使用严格模式</span></span><br></pre></td></tr></table></figure>
<h5 id="【变量】"><a href="#【变量】" class="headerlink" title="【变量】"></a>【变量】</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">"hi"</span>;              <span class="comment">//声明字符串</span></span><br><span class="line">message = <span class="number">100</span>;              <span class="comment">//把message类型转数值类型，并赋值，合法，但不推荐</span></span><br></pre></td></tr></table></figure>
<h5 id="【数据类型】"><a href="#【数据类型】" class="headerlink" title="【数据类型】"></a>【数据类型】</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert(<span class="keyword">typeof</span>(<span class="number">95</span>));    <span class="keyword">typeof</span>是一个操作符而不是函数，括号可省略<span class="keyword">typeof</span> <span class="number">95</span></span><br></pre></td></tr></table></figure>
<p><strong>包含undefined值的变量与未定义的变量是不一样的,但typeof()出来的值却都是undefined</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> message;               </span><br><span class="line">alert(message);            <span class="comment">//"undefined"</span></span><br><span class="line">alert(age);                <span class="comment">//产生错误</span></span><br><span class="line">alert(<span class="keyword">typeof</span> message);     <span class="comment">//"undefined"</span></span><br><span class="line">alert(<span class="keyword">typeof</span> age);         <span class="comment">//"undefined"</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>null类型</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> car = <span class="literal">null</span>;</span><br><span class="line">alert(<span class="keyword">typeof</span> car);    <span class="comment">//"object",返回对象</span></span><br><span class="line">alert(<span class="literal">null</span> == <span class="literal">undefined</span>);   <span class="comment">//true，这是由于undefined值是派生自null值</span></span><br></pre></td></tr></table></figure>
<p> <strong>Boolean()可把一个值转换为boolean值</strong></p>
<ul>
<li>Number类型</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="number">070</span>;   <span class="comment">//八进制的56，前面加0表示八进制  </span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="number">079</span>;   <span class="comment">//无效的八进制，9大于8，按十进制处理，解析为79</span></span><br><span class="line"><span class="keyword">var</span> num3 = <span class="number">0xA</span>;   <span class="comment">//十六进制的10</span></span><br></pre></td></tr></table></figure>
<p><strong>进行算术运算时，八进制和十进制的数值都将转换成十进制数值，八进制字面量在严格模式下是无效的</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> float1 = <span class="number">1.</span>;   <span class="comment">//小数点后没有数字，解析为1</span></span><br><span class="line"><span class="keyword">var</span> float2 = <span class="number">10.0</span>  <span class="comment">//小数点后面是0，自动解析为整数10</span></span><br></pre></td></tr></table></figure>
<p><strong>浮点数所需空间是整数的两倍，小数运算问题总是得不到预期的结果</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.MIN_VALUE  <span class="comment">//表示最小的数，大多数浏览器中为5e-324，比这小则转为负无穷-Infinity</span></span><br><span class="line"><span class="built_in">Number</span>.MAX_VALUE  <span class="comment">//最大的数，比这大则转为正无穷Infinity</span></span><br><span class="line"><span class="built_in">isFinite</span>()        <span class="comment">//判断是否在数值范围内，即最大值与最小值之间</span></span><br><span class="line"><span class="built_in">Number</span>.NEGATIVE_INFINITY   <span class="comment">//负无穷-Infinity,对应有Number.POSITIVE_INFINITY</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert(<span class="literal">NaN</span> == <span class="literal">NaN</span>);    <span class="comment">//false，非数字NaN与任何值都不相等，包括自身</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">true</span>);    <span class="comment">//false，判断是否非数字，会尝试把true转换成数值1</span></span><br></pre></td></tr></table></figure>
<p><strong>数值转换Number()、paseInt()和parseFloat()</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="built_in">Number</span>(<span class="string">""</span>);         <span class="comment">//0，空字符串转换为0</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="built_in">Number</span>(<span class="string">"00011"</span>);    <span class="comment">//11，只包含数字的字符串，转换为对应的数字</span></span><br><span class="line"><span class="keyword">var</span> num3 = <span class="built_in">Number</span>(<span class="literal">true</span>);       <span class="comment">//1，boolean型转换为0或1</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="built_in">parseInt</span>(<span class="string">"123blue"</span>);     <span class="comment">//1234，必须前面为数字或负号才能转换，否则NaN</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="built_in">parseInt</span>(<span class="string">""</span>);            <span class="comment">//NaN，空字符串</span></span><br><span class="line"><span class="keyword">var</span> num3 = <span class="built_in">parseInt</span>(<span class="string">"070"</span>);         <span class="comment">//0开头的，ECMAScript 5认为是70，而3中认为是56（八进制）</span></span><br><span class="line"><span class="keyword">var</span> num4 = <span class="built_in">parseInt</span>(<span class="string">"0xA"</span>,<span class="number">16</span>);      <span class="comment">//175，指定为十六进制，此时前面的0x可以省略</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="built_in">parseFloat</span>(<span class="string">"22.52.3"</span>);     <span class="comment">//22.52，只解析一个小数点</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="built_in">parseFloat</span>(<span class="string">"0xA"</span>);         <span class="comment">//0，只解析十进制，没有第二个参数来指定进制</span></span><br><span class="line"><span class="keyword">var</span> num3 = <span class="built_in">parseFloat</span>(<span class="string">"3.125e7"</span>);     <span class="comment">//31250000</span></span><br></pre></td></tr></table></figure>
<ul>
<li>字符串类型</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"This is yoomin:\u03a3."</span>;    <span class="comment">//6个字符长的转义序列\u03a3表示1个字符</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lang = <span class="string">"Java"</span>;         <span class="comment">//字符串一旦创建它们的值就不能改变</span></span><br><span class="line">lang = lang + <span class="string">"Script"</span>;    <span class="comment">//改变字符串须先销毁，再用新的字符串填充该变量，这些是在后台执行的。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line">alert(num.toString(<span class="number">8</span>));   <span class="comment">//"12"，转为字符串以8进制表示，缺省为10进制，null和undefined值没有这个方法</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Object类型</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();    <span class="comment">//有效，但不推荐</span></span><br></pre></td></tr></table></figure>
<p><strong>Object的常用方法和属性</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>constructor</td>
<td>表示创建当前对象的函数，即构造函数</td>
<td>hasOwnProperty(property)</td>
<td>检查属性property是否在当前对象实例中</td>
</tr>
<tr>
<td>toLocalString()</td>
<td>返回对象的字符串表示</td>
<td>valueOf()</td>
<td>返回对象的字符串、数值或布尔值表示，通常与toString()返回值相同</td>
</tr>
</tbody>
</table>
<p><strong>补充：</strong> Object是所有对象的基础，因此所有对象都有这些基本的属性和方法</p>
<p>#####【操作符】</p>
<ul>
<li>操作符应用于对象时通常会调用对象的valueOf()和（或）toString()方法，以便取得可以操作的值</li>
<li>自增或自减操作符都可以用于字符串、布尔值、浮点数和对象</li>
<li>一元操作符以一个加号（+）号表示，对数值不会产生影响</li>
<li>所有数值都以64位格式存储，位操作符先将数值转为32位的整数，然后执行操作，再将结果转回64位</li>
<li>数值默认都是有符号整数，第32位表示符号</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> oldValue = <span class="number">2</span>;               <span class="comment">//二进制10</span></span><br><span class="line"><span class="keyword">var</span> newValue = oldValue &lt;&lt; <span class="number">5</span>;    <span class="comment">//二进制1000000，十进制的64，左移以0填充空位，不会影响符号位</span></span><br><span class="line"><span class="keyword">var</span> newValue = oldValue &gt;&gt; <span class="number">5</span>;    <span class="comment">//有符号右移，会用符号位的值来填充空位</span></span><br><span class="line"><span class="keyword">var</span> newValue = oldValue &gt;&gt;&gt; <span class="number">5</span>;   <span class="comment">//无符号右移，将数值的所有32位都向右移动，正数的移与有符号右移相同</span></span><br></pre></td></tr></table></figure>
<p><strong>逻辑非</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert(!<span class="literal">NaN</span>);     <span class="comment">//true,NaN在布尔操作符中表示false</span></span><br><span class="line">alert(!!<span class="literal">NaN</span>);    <span class="comment">//连续使用两个!相当于使用Boolean()转为布尔型</span></span><br></pre></td></tr></table></figure></p>
<p><strong>逻辑与</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert(<span class="literal">null</span>&amp;&amp;<span class="string">"hello"</span>);     <span class="comment">//null,有一个null则返回Null，NaN和undefined也是如此</span></span><br><span class="line"><span class="keyword">var</span> result = (<span class="literal">false</span>&amp;&amp;undefinedNumber);    <span class="comment">//后面的undefinedNumber是有错的，但不会执行所以没有报错，因为被&amp;&amp;短路了</span></span><br></pre></td></tr></table></figure></p>
<p><strong>逻辑或</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert(<span class="literal">null</span>||<span class="string">"hello"</span>);     <span class="comment">//null,两个都是null则返回Null，NaN和undefined也是如此</span></span><br><span class="line"><span class="keyword">var</span> result = (<span class="literal">false</span>&amp;&amp;undefinedNumber);    <span class="comment">//后面的undefinedNumber是有错的，但不会执行所以没有报错，因为被&amp;&amp;短路了</span></span><br></pre></td></tr></table></figure></p>
<p><strong>乘性操作符</strong></p>
<ul>
<li>Infinity*0，结果为NaN</li>
<li>Infinity/Infinity结果NaN</li>
<li>0 / 0结果NaN</li>
<li>0 / number 结果为Infinity或-Infinity</li>
</ul>
<p><strong>加性操作符</strong></p>
<ul>
<li>Infinity加-Infinity是NaN</li>
<li>+0加-0是-0</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert(<span class="number">5</span>+<span class="string">"5"</span>);  <span class="comment">//"55"，数值和字符串相加变成字符串</span></span><br><span class="line">alert(<span class="string">"五加五等于："</span> + <span class="number">5</span> + <span class="number">5</span>);   <span class="comment">//"五加五等于：55"，如果想得到10，后面两个5就用括号括起来</span></span><br></pre></td></tr></table></figure>
<p><strong>关系操作符</strong></p>
<ul>
<li>两个都是字符串则比较字符串编码，大写字母的字符编码全部小于小写字母，若要比较，可用toLowerCase()</li>
<li>有一个操作数是数值，则将另一个转换成为数值再比较</li>
<li>任何数与NaN比较，都是false</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="string">"23"</span> &lt; <span class="number">3</span>;   <span class="comment">//true，因为两个都是字符串，比较的是字符编码</span></span><br><span class="line"><span class="keyword">var</span> result1 = <span class="literal">NaN</span> &lt; <span class="number">3</span>;   <span class="comment">//false    </span></span><br><span class="line"><span class="keyword">var</span> result2 = <span class="literal">NaN</span> &gt;= <span class="number">3</span>;   <span class="comment">//false，因为任何数与NaN比较都是false</span></span><br></pre></td></tr></table></figure>
<p><strong>相等操作符</strong></p>
<ul>
<li><code>==</code> 相等，先转换后比较</li>
<li><code>===</code> 全等，仅比较而不转换</li>
<li>任何数与NaN不相等</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span>;   <span class="comment">//true,两者是相等的</span></span><br><span class="line"><span class="keyword">var</span> result1 = (<span class="string">"55"</span> == <span class="number">55</span>);  <span class="comment">//true,因为转换后相等</span></span><br><span class="line"><span class="keyword">var</span> result2 = (<span class="string">"55"</span> === <span class="number">55</span>);  <span class="comment">//fause</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> max = (num1 &gt; num2) ? num1 : num2;    <span class="comment">//用条件操作符求两个数的最大值</span></span><br></pre></td></tr></table></figure>
<p><strong>使用<code>+=</code>等操作符不会带来性能上的提升</strong></p>
<ul>
<li>for循环后面括号里定义的i在外部仍可访问</li>
<li><code>for-in</code>用于枚举对象的属性<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> propName <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</span><br><span class="line">	documet.write(propName);    <span class="comment">//输出的属性名的顺序是不可预测的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span>(location) &#123;</span><br><span class="line">	<span class="keyword">var</span> qs = search.substring(<span class="number">1</span>);   <span class="comment">//等价于location.search.substring(1)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>case语句的break如不写则表示与后面的带break的case执行同样的命令</strong></p>
<h5 id="【函数】"><a href="#【函数】" class="headerlink" title="【函数】"></a>【函数】</h5><ul>
<li>位于<code>return</code>语句后面的语句都不会执行，遇到<code>return</code>函数立即退出</li>
<li>函数参数arguments与数组类似，但不是Array的实例，可用length来获取长度及下标取得值</li>
<li>arguments的值是可以修改的</li>
<li>没有重载的概念，因为没有函数签名</li>
</ul>
<h4 id="四、变量、作用域和内存问题"><a href="#四、变量、作用域和内存问题" class="headerlink" title="四、变量、作用域和内存问题"></a>四、变量、作用域和内存问题</h4><hr>
<h5 id="【4-1基本类型和引用类型的值】"><a href="#【4-1基本类型和引用类型的值】" class="headerlink" title="【4.1基本类型和引用类型的值】"></a>【4.1基本类型和引用类型的值】</h5><ul>
<li>引用类型的值是保存在内存中的对象，不能直接操作对象的内存空间，只能通过操作对象的引用而不是对象。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name = <span class="string">"yoomin"</span>;    <span class="comment">//添加属性name</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"yoomin"</span>;</span><br><span class="line">name.age = <span class="number">27</span>;       <span class="comment">//不能给基本类型添加属性，虽然不会报错</span></span><br><span class="line">alert(name.age);    <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">var</span> obj2 = obj1;   <span class="comment">//两者指向同一对象，操作时会同步</span></span><br></pre></td></tr></table></figure>
<p><strong>检测类型</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert(<span class="keyword">typeof</span> <span class="literal">null</span>);   <span class="comment">//typeof检测对象或null会返回object</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert(person <span class="keyword">instanceof</span> <span class="built_in">Array</span>);    <span class="comment">//instanceof判断某变量是否某种类型，是返回true</span></span><br><span class="line">alert(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>);   <span class="comment">//所有引用类型都是Object的实例，person是引用类型都会返回true</span></span><br></pre></td></tr></table></figure>
<h5 id="【4-2执行环境及作用域】"><a href="#【4-2执行环境及作用域】" class="headerlink" title="【4.2执行环境及作用域】"></a>【4.2执行环境及作用域】</h5><ul>
<li>执行环境里定义了有权访问的数据，每个执行环境都有一个与之关联的变量对象</li>
<li>当代码在一个环境中执行时，会创建变量对象的一个作用域链，全局执行环境的变量对象（全局属性）始终是作用域链的最后一个对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>) &#123;<span class="keyword">var</span> color = <span class="string">"blue"</span>&#125;</span><br><span class="line">alert(color);  <span class="comment">//"blue"，JS中没有块级作用域,for循环里面的变量也会存在于循环外部的执行环境中</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sum = <span class="number">0</span>;    <span class="comment">//严格模式下，初始化未声明的变量会导致错误，非严格模式下表示全局变量</span></span><br></pre></td></tr></table></figure>
<h5 id="【4-3垃圾收集】"><a href="#【4-3垃圾收集】" class="headerlink" title="【4.3垃圾收集】"></a>【4.3垃圾收集】</h5><ul>
<li>标记：使用标记标记变量进入环境，所有主流浏览器都是用标记清除式垃圾收集机制，只是垃圾收集的时间间隔不同<br>-引用计数：用数字表示引用次数，当引用次数为0时则可回收</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'id'</span>);</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.element = element;</span><br><span class="line">element.someObject = obj;   <span class="comment">//对象互相引用，引用次数永不为0，因为不会回收</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">obj.element = <span class="literal">null</span>;</span><br><span class="line">element.someObject = <span class="literal">null</span>;   <span class="comment">//在不使用时应手动回收，叫解除引用</span></span><br></pre></td></tr></table></figure>
<h4 id="五、引用类型"><a href="#五、引用类型" class="headerlink" title="五、引用类型"></a>五、引用类型</h4><hr>
<h5 id="【5-1-Object类型】"><a href="#【5-1-Object类型】" class="headerlink" title="【5.1 Object类型】"></a>【5.1 Object类型】</h5><p><strong>创建Object</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();  <span class="comment">//使用new操作符</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;name:<span class="string">"yoomin"</span>,age:<span class="number">23</span>&#125;;   <span class="comment">//对象字面量表示法，不会调用Objcect构造函数</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;&#125;;   <span class="comment">//与new Object()相同</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;<span class="number">1</span>:<span class="literal">true</span>&#125;;   <span class="comment">//可使用数值作属性，但会转换成字符串</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert(person[<span class="string">"your name"</span>]);   <span class="comment">//访问your name属性，可包含特殊字符或某些关键字</span></span><br><span class="line">alert(person.name);   <span class="comment">//访问name属性，不可用特殊字符或关键字</span></span><br></pre></td></tr></table></figure>
<h5 id="【5-2-Array类型】"><a href="#【5-2-Array类型】" class="headerlink" title="【5.2 Array类型】"></a>【5.2 Array类型】</h5><p><strong>创建数组</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);   <span class="comment">//new可省略</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"yoomin"</span>);   <span class="comment">//new可省略</span></span><br><span class="line"><span class="keyword">var</span> colors = [<span class="string">"blue"</span>,<span class="string">"yellow"</span>];</span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"blue"</span>,<span class="string">"yellow"</span>];</span><br><span class="line">colors.length = <span class="number">1</span>;   <span class="comment">//数组的长度不是只读的，可设置，增加长度时用undefined填充</span></span><br><span class="line">alert(colors[<span class="number">2</span>]);   <span class="comment">//undefined</span></span><br><span class="line">colors[colors.length] = <span class="string">"black"</span>;   <span class="comment">//在末尾添加一种颜色，长度自动加1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArray(value);   <span class="comment">//检测数组</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert(colors.toString());   <span class="comment">//blue,yellow，toString()方法返回用逗号分割的字符串</span></span><br><span class="line">alert(colors.valueOf());   <span class="comment">//blue,yellow，valueOf()方法返回的还是数组，和直接alert的数组一样</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert(colors.join(<span class="string">"||"</span>));  <span class="comment">//blue||yello，join()方法表示使用某字符串分割数组，缺省为逗号","</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>栈方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">var</span> count  = colors.push(<span class="string">"red"</span>,<span class="string">"green"</span>);   <span class="comment">//插入两项，新数组的长度count = 2</span></span><br><span class="line"><span class="keyword">var</span> item = colors.pop();   <span class="comment">//移除并取得最后一项</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>队列方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">var</span> item = colors.shift();   <span class="comment">//删除并取得第一项</span></span><br><span class="line"><span class="keyword">var</span> count = colors.unshift(<span class="string">"red"</span>,<span class="string">"green"</span>);    <span class="comment">//在开头插入两项，并返回新数组的软件</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>排序方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> value = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">values.reverse();   <span class="comment">//reverse()将数组反序并保存到自身</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">values.sort();   <span class="comment">//按升序排序数组，总是根据字符串来排序，数字会转成字符串，有时会不准确</span></span><br><span class="line">values.sort(compare);   <span class="comment">//将一个函数作参数传给sort()，实现各种数据类型排序</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1,value2</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(value1 &lt; value2) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是数值类型排序更简单<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1,value2</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> value2 - value1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>操作方法<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colors2 = colors1.concat(<span class="string">"yello"</span>,[<span class="string">"balck"</span>,<span class="string">"brown"</span>]);  <span class="comment">//拼接数组，可传入一个或多个数组，不会改变colors1本身</span></span><br><span class="line"><span class="keyword">var</span> colors2 = colors.slice(<span class="number">1</span>);   <span class="comment">//返回数组从下标1到结束的部分，负数表示倒数</span></span><br><span class="line"><span class="keyword">var</span> colors3 = colors.slice(<span class="number">1</span>,<span class="number">4</span>);   <span class="comment">//从位置1开始，到位置3结束，即4的前一个，位置指下标</span></span><br><span class="line"><span class="keyword">var</span> colors4 = colors.slice(<span class="number">-1</span>);    <span class="comment">//小于起始位置，返回空数组</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">splice(<span class="number">0</span>,<span class="number">2</span>);   <span class="comment">//从位置0开始删除两项，splice()始终返回删除的数组项，没有则返回空数组</span></span><br><span class="line">splice(<span class="number">2</span>,<span class="number">0</span>,<span class="string">"red"</span>,<span class="string">"green"</span>);   <span class="comment">//从位置0开始删除2项并插入red,green</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">numbers.indexOf(<span class="number">4</span>);   <span class="comment">//返回位置4的值，indexOf()不适用于IE8及以下</span></span><br></pre></td></tr></table></figure>
<ul>
<li>迭代与归并<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> everyResult = numbers.every(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,array</span>) </span>&#123;    <span class="comment">//every()判断每一项都为true时才返回true，否则false</span></span><br><span class="line">	<span class="keyword">return</span> (item &gt; <span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line">some();    <span class="comment">//some()方法则只要有一个为true则返回true</span></span><br><span class="line">filter();   <span class="comment">//筛选满足条件的值，并生成一个新的数组</span></span><br><span class="line">map();     <span class="comment">//操作每一项，例如把每一项都加倍</span></span><br><span class="line">forEach();   <span class="comment">//对每一项运行传入的函数，此方法没有返回值，直接对原数组操作</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> sum = values.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, array</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> prev + cur;     <span class="comment">//round 1: prev=1,cur=2, round 2: prev=3,cur=3(数组第三项)</span></span><br><span class="line">&#125;);</span><br><span class="line">reduceRight();      <span class="comment">//使用类似，但方向相反，从后面开始运算，此两方法不适用IE8及以下</span></span><br></pre></td></tr></table></figure>
<h5 id="【5-3-Date类型】"><a href="#【5-3-Date类型】" class="headerlink" title="【5.3 Date类型】"></a>【5.3 Date类型】</h5><ul>
<li>日期是用从1970年1月1月0时开始经过的毫秒数来保存的</li>
<li>创建日期<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> someDate = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.parse(<span class="string">"May 25,2004"</span>));  <span class="comment">//传入一个字符串，还支持5/24/2004，返回毫秒数</span></span><br><span class="line"><span class="keyword">var</span> someDate2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">"May 25,2004"</span>);   <span class="comment">//与上面等价</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> someDate = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.UTC(<span class="number">2005</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">17</span>,<span class="number">55</span>,<span class="number">55</span>));  <span class="comment">//GMT时间2005年5月5日17:55:55,返回毫秒数，只有前两个参数是必须的，日期缺省为1，其他为0</span></span><br><span class="line"><span class="keyword">var</span> allFives = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2005</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">17</span>,<span class="number">55</span>,<span class="number">55</span>);     <span class="comment">//Date()构造方法和上面完全相同</span></span><br></pre></td></tr></table></figure>
<p><em><code>toLocaleString()</code>和<code>toString()</code>在不同的浏览器中显示差别很大，基本不使用</em></p>
<h5 id="【5-4-RegExp类型】？？？？？？？？？？？？"><a href="#【5-4-RegExp类型】？？？？？？？？？？？？" class="headerlink" title="【5.4 RegExp类型】？？？？？？？？？？？？"></a>【5.4 RegExp类型】？？？？？？？？？？？？</h5><h5 id="【5-5-Function类型】"><a href="#【5-5-Function类型】" class="headerlink" title="【5.5 Function类型】"></a>【5.5 Function类型】</h5><ul>
<li>定义函数<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1,num2</span>) </span>&#123;     <span class="comment">//函数声明语法定义</span></span><br><span class="line">	<span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1,num2</span>) </span>&#123;    <span class="comment">//函数表达式定义函数，此处要先定义后使用，没有函数提升</span></span><br><span class="line">	<span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;     <span class="comment">//此分号不可省略，就像声明其他变量时一样</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;<span class="comment">//some code&#125;</span></span><br><span class="line">sum2 = sum;</span><br><span class="line">sum = <span class="literal">null</span>;   <span class="comment">//把sum设置为Null后，sum2仍能使用，因为函数名只是个引用</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;    <span class="comment">//阶乘函数</span></span><br><span class="line">	<span class="keyword">if</span>(num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num<span class="number">-1</span>)      <span class="comment">//callee是参数对象arguments的一个属性，表示调用的函数自身</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>若使用函数名来调用自身，当赋值给其他变量并重新定义自身时，其他变量调用递归将出错</em><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;inner();&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	alert(inner.caller);     <span class="comment">//caller表示调用inner函数的函数的引用，在这里指outer()</span></span><br><span class="line">	alert(<span class="built_in">arguments</span>.callee.caller);     <span class="comment">//和上面一样，但低耦合更好</span></span><br><span class="line">&#125;</span><br><span class="line">outer();</span><br></pre></td></tr></table></figure></p>
<p><em>严格模式下，<code>arguments.callee</code>会导致错误</em></p>
<ul>
<li>函数属性和方法</li>
</ul>
<p>函数是对象，每个函数都有两个属性：length和prototype，length表示参数的个数，prototype是保存它们所有实例方法的所在，prototype属性是不可枚举的，因此使用for-in无法发现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">sum1,sum2</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum1</span>(<span class="params">num1,num2</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> sum.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);    <span class="comment">//表示将callSum1的this传入到sum里面做sum的this，sum.apply(this,arguments)实际上修改了sum的this</span></span><br><span class="line">	<span class="comment">//return sum.apply(this.[num1,num2]);   //也可将参数当成数组传入，与上面返回一样的结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> sum.call(<span class="keyword">this</span>,num1,num2);    <span class="comment">//和apply方法一样，只是参数要一个一个列举出来，而不能用数组</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;color:<span class="string">"blue"</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	alert(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line">sayColor.call(<span class="keyword">this</span>);   <span class="comment">//red，此时是window在调用sayColor方法</span></span><br><span class="line">sayColor.call(<span class="built_in">window</span>);   <span class="comment">//red，把window传入方法，当作方法的this</span></span><br><span class="line">sayColor.call(o);     <span class="comment">//blue，把o传处，sayColor里的this即表示o</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> objectSayColor = sayColor.bind(o);   <span class="comment">//sayColor方法赋值给objectSayColor方法，并把对象o的this传入objectSayColor方法中，此方法不适用IE8及以下</span></span><br></pre></td></tr></table></figure>
<h5 id="【5-6-基本包装类型】"><a href="#【5-6-基本包装类型】" class="headerlink" title="【5.6 基本包装类型】"></a>【5.6 基本包装类型】</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">"some text"</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = s1.substring(<span class="number">2</span>);    <span class="comment">//后台把基本类型s1包装，暂时成为字符串包装对象</span></span><br><span class="line">s1.color = <span class="string">"red"</span>;    <span class="comment">//在执行这句语句的时候s1是具有color属性的对象</span></span><br><span class="line">alert(s1.color);     <span class="comment">//undefined，此时s1.color新建了一个对象，但这个对象没有color属性</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="string">"some text"</span>);    <span class="comment">//传入的若是数字则变成Number的实例，布尔值类似</span></span><br><span class="line">alert(obj <span class="keyword">instanceof</span> <span class="built_in">String</span>);   <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> number = <span class="built_in">Number</span>(<span class="string">"25"</span>);   <span class="comment">//转型函数，typeof number是number</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">25</span>);    <span class="comment">//构造函数，typeof obj是object</span></span><br></pre></td></tr></table></figure>
<ul>
<li>布尔类型</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> falseObject = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);   <span class="comment">//创建布尔对象,建议永远不要使用布尔对象</span></span><br><span class="line"><span class="keyword">var</span> falseValue = <span class="literal">false</span>;    <span class="comment">//字面量声明布尔值</span></span><br><span class="line">alert(<span class="keyword">typeof</span> falseObject);   <span class="comment">//object</span></span><br><span class="line">alert(<span class="keyword">typeof</span> falseValue);    <span class="comment">//boolean</span></span><br><span class="line">alert(falseValue <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>);    <span class="comment">//false，表达式声明的不是Boolean对象</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line">alert(num.toExponential(<span class="number">1</span>));   <span class="comment">//"1.0e+1"，以指数标示法返回值，指定为1位小数</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">99</span>;</span><br><span class="line">alert(num.toPrecision(<span class="number">1</span>));   <span class="comment">//"1e+2"，用1位数字表示，自动使用科学计数法</span></span><br><span class="line">alert(num.toPrecision(<span class="number">2</span>));   <span class="comment">//"99"，参数表示用2个数字表示</span></span><br><span class="line">alert(num.toPrecision(<span class="number">3</span>));   <span class="comment">//"99.0"，用3个数字表示，自动使用toFixed()保留一位小数，加上整数2位共3位</span></span><br></pre></td></tr></table></figure>
<ul>
<li>String类型<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert(<span class="string">"hello world"</span>.charAt(<span class="number">1</span>));   <span class="comment">//"e"，返回在位置1的字符</span></span><br><span class="line">alert(<span class="string">"hello world"</span>.charCodeAt(<span class="number">1</span>));   <span class="comment">//"101"，返回返回字符编码</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>IE8以上及现代浏览器还支持直接下标获取字符</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello "</span>;</span><br><span class="line"><span class="keyword">var</span> result = stringValue.concat(<span class="string">"world"</span>,<span class="string">"!"</span>);   <span class="comment">//concat可传入任何个参数，也就是可任意个字符串，但不改变原先数组的值</span></span><br></pre></td></tr></table></figure>
<p>操作字符串<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">string.slice(<span class="number">3</span>);   <span class="comment">//返回从位置3到结束位置的子字符串</span></span><br><span class="line">string.substring(<span class="number">3</span>);    <span class="comment">//同上</span></span><br><span class="line">string.substr(<span class="number">3</span>);   <span class="comment">//同上</span></span><br><span class="line">string.slice(<span class="number">3</span>,<span class="number">7</span>);   <span class="comment">//返回从3到位置6的字符串，substring(3,7)也一样</span></span><br><span class="line">string.substr(<span class="number">3</span>,<span class="number">7</span>);   <span class="comment">//从位置3开始，返回7个字符</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">string.slice(<span class="number">-5</span>,<span class="number">-4</span>);    <span class="comment">//负数表示倒数</span></span><br><span class="line">substr(<span class="number">-5</span>,<span class="number">-4</span>);     <span class="comment">//第一个负数表示倒数，后面一个会转换为0</span></span><br><span class="line">substring(<span class="number">-5</span>,<span class="number">-4</span>);    <span class="comment">//所有负数都转换为0</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">string.indexOf(<span class="string">"o"</span>,<span class="number">6</span>);   <span class="comment">//从位置6开始向后查找字符"o"，返回第一次找到的下标，第二个参数可省略</span></span><br><span class="line">string.lastIndexOf(<span class="string">"o"</span>,<span class="number">6</span>);   <span class="comment">//从位置6向前开始查找，第二个参数也可省略</span></span><br></pre></td></tr></table></figure>
<p>若要找到所有匹配字符的下标，可使用如下方法：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> positions = <span class="keyword">new</span> <span class="built_in">Array</span>();   <span class="comment">//用于保存找到的下标</span></span><br><span class="line"><span class="keyword">var</span> pos = string.indexOf(<span class="string">"e"</span>);</span><br><span class="line"><span class="keyword">while</span>(pos &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">	positions.push(pos);   <span class="comment">//将找到的这一下标保存到positions数组</span></span><br><span class="line">	pos = string.indexOf(<span class="string">"e"</span>, pos + <span class="number">1</span>);     <span class="comment">//从上次找到的下一个位置开始查找</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"    hello world    "</span>.trim();    <span class="comment">//"hello world"，trim()方法去掉字符串两头的空格，IE8及以下不支持，类似还有trimLeft(),trimRight()</span></span><br></pre></td></tr></table></figure>
<p>字符串的模式匹配方法P126 ？？？？？？？？？？？？？？？？？？？？？？？？<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sringValue = <span class="string">"yellow"</span>;</span><br><span class="line">stringValue.localeCompare(<span class="string">"brick"</span>);    <span class="comment">//1，因为brick在字母表中排在yellow之前，若和yellow比较则相等，返回0，在之后则返回-1</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>.fromCharCode(<span class="number">104</span>,<span class="number">101</span>,<span class="number">108</span>,<span class="number">108</span>,<span class="number">111</span>);   <span class="comment">//"hello"，把编码转成字符串</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">anchor(name);    <span class="comment">//输出&lt;a name = "name"&gt;string&lt;/a&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="【单体内置对象】"><a href="#【单体内置对象】" class="headerlink" title="【单体内置对象】"></a>【单体内置对象】</h5><ul>
<li>Global对象</li>
</ul>
<p>有效的URI（通用资源标识符）不能包含某些字符，可以让特殊的UTF-8编码替换所有无效的字符，其中<code>encodeURI()</code>主要用于整个URI，只替换了空格，而<code>URIComponent()</code>主要用于URI中的某一段，会替换所有非数字字符。对应的解码是<code>decodeURI()</code>和<code>decodeURIComponent()</code>，<code>escape()</code>和<code>unescape()</code>已被废弃<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">"var msg = 'hello world';"</span>);</span><br><span class="line">alert(msg);    <span class="comment">//"hello world"，可以调用eval定义的变量</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> global = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>;    <span class="comment">//取得全局对象的另一种方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Math对象<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> max = <span class="built_in">Math</span>.max(<span class="number">3</span>,<span class="number">54</span>,<span class="number">32</span>,<span class="number">16</span>);   <span class="comment">//求最大值</span></span><br><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>];</span><br><span class="line"><span class="keyword">var</span> max = <span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>,values);   <span class="comment">//求最大值的特别方法，把Math对象传入apply设置为this，可以方便对数组求最大值</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>其他方法：</strong>Math.ceil()向上舍入取整，Math.floor()向下舍入，Math.round()四舍五入，Math.abs()求绝对值</p>
<h4 id="六、面向对象的程序设计"><a href="#六、面向对象的程序设计" class="headerlink" title="六、面向对象的程序设计"></a>六、面向对象的程序设计</h4><hr>
<h5 id="【理解对象】"><a href="#【理解对象】" class="headerlink" title="【理解对象】"></a>【理解对象】</h5><p><strong>属性类型：</strong>属性分为数据属性和访问器属性</p>
<table>
<thead>
<tr>
<th>数据属性特性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Configurable</td>
<td>能否通过<code>delete</code>删除属性从而重新定义属性，直接在对象上定义的属性默认为true</td>
</tr>
<tr>
<td>Enumerable</td>
<td>能否通过<code>for-in</code>遍历，直接在对象上定义的属性默认为true</td>
</tr>
<tr>
<td>Writable</td>
<td>能否修改属性的值，直接在对象上定义的属性默认为true</td>
</tr>
<tr>
<td>Value</td>
<td>包含这个属性的数据值，读取属性的时候从这个位置读取，默认为undefined</td>
</tr>
</tbody>
</table>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;    <span class="comment">//此方法用于修改属性默认的特性</span></span><br><span class="line">	writable: <span class="literal">false</span>,                       <span class="comment">//三个参数为属性所在的对象，属性名，和描述符对象</span></span><br><span class="line">	value: <span class="string">"yoomin"</span>,</span><br><span class="line">	configurable: <span class="literal">false</span>        <span class="comment">//设置为false不能再改回true，</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>修改除writable之外的特性为false后，不能再修改回来true，否则报错，建议不要在IE8中使用defineProperty()</p>
<table>
<thead>
<tr>
<th>访问器属性特性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Configurable</td>
<td>能否通过<code>delete</code>删除属性从而重新定义属性，直接在对象上定义的属性默认为true</td>
</tr>
<tr>
<td>Enumerable</td>
<td>能否通过<code>for-in</code>遍历，直接在对象上定义的属性默认为true</td>
</tr>
<tr>
<td>Get</td>
<td>在读取属性是调用的函数，默认为undefined</td>
</tr>
<tr>
<td>Set</td>
<td>在写入属性时调用的函数，默认为undefined</td>
</tr>
</tbody>
</table>
<p>访问属性不能直接定义，必须使用Object.defineProperty()来定义<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;_year:<span class="number">2004</span>, edition:<span class="number">1</span>&#125;;   <span class="comment">//_year下划线用于表示只能通过对象方法访问的属性</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(book,<span class="string">"year"</span>, &#123;     <span class="comment">//IE8只是部分实现此方法，不建议使用</span></span><br><span class="line">	get:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>._year;</span><br><span class="line">	&#125;,</span><br><span class="line">	set:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(newValue &gt; <span class="number">2004</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>._year = newValue;</span><br><span class="line">			<span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;   <span class="comment">//设置_year的同时也会设置edition，这是访问器属性的觉见用法</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//只指定get意味着属性可读不可写，只指定set的表示属性不能读</span></span><br></pre></td></tr></table></figure></p>
<p><strong>补充：</strong><code>Object.defineProperties()</code>用于一次定义多个属性<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book,<span class="string">"year"</span>);   <span class="comment">//读取属性的特性，IE8及以下不支持</span></span><br><span class="line">alert(descriptor.value);    <span class="comment">//2004，读取属性的value特性值</span></span><br></pre></td></tr></table></figure></p>
<h5 id="【6-2-创建对象】"><a href="#【6-2-创建对象】" class="headerlink" title="【6.2 创建对象】"></a>【6.2 创建对象】</h5><ul>
<li>工厂模式</li>
</ul>
<p>用函数模拟类，封装以特定接口创建对象的细节<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();    <span class="comment">//函数内部创建一个对象</span></span><br><span class="line">	o.name = name;      <span class="comment">//设置属性</span></span><br><span class="line">	o.age = age;</span><br><span class="line">	o.job = job;</span><br><span class="line">	o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		alert(<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> yoomi = createPerson(<span class="string">"yoomin"</span>,<span class="number">23</span>,<span class="string">"IT"</span>);</span><br></pre></td></tr></table></figure></p>
<ul>
<li>构造函数模式</li>
</ul>
<p>工厂模式解决了创建多个相似对象的问题，但没有解决对象识别的问题（怎么知道一个对象的类型），于是有了构造函数模式<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;    <span class="comment">//按照惯例，构造函数第一个字母应该大写</span></span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">	<span class="keyword">this</span>.job = job;</span><br><span class="line">	<span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		alert(<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"yoomin"</span>,<span class="number">23</span>,<span class="string">"IT"</span>);</span><br></pre></td></tr></table></figure></p>
<p>创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型，这正是构造函数模式胜过工厂模式的地方：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert(person1.constructor == Person);   <span class="comment">//true</span></span><br><span class="line">alert(person1 <span class="keyword">instanceof</span> Person);   <span class="comment">//true</span></span><br><span class="line">alert(person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);   <span class="comment">//true，也是个Object对象</span></span><br></pre></td></tr></table></figure></p>
<p>任何函数，只要通过new操作符来调用，就可以成为构造函数，否则就是普通函数：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当作构造函数用</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"yoomin"</span>,<span class="number">23</span>,<span class="string">"IT"</span>);</span><br><span class="line">person.sayName();   <span class="comment">//"yoomin"</span></span><br><span class="line"><span class="comment">//作为普通函数用</span></span><br><span class="line">Person(<span class="string">"yongming"</span>,<span class="number">24</span>,<span class="string">"IT"</span>);   <span class="comment">// 添加到window</span></span><br><span class="line"><span class="built_in">window</span>.sayName();</span><br><span class="line"><span class="comment">//在另一个对象的作用域中调用</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">Person.call(o,<span class="string">"yoomin"</span>,<span class="number">23</span>,<span class="string">"IT"</span>);</span><br><span class="line">o.sayName();   <span class="comment">//"yoomin"</span></span><br></pre></td></tr></table></figure></p>
<p>Person构造函数有sayName()方法，创建多个Person实例时也会产生多个sayName()的Function对象，可这样改进：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.sayName = sayName;   <span class="comment">//把函数引用引进来，只需创建一个function实例</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>原型模式</li>
</ul>
<p>每个函数都有一个prototype（原型）属性，可以让所有实例共享信息：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Person.prototype.name = <span class="string">"yoomin"</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.sayName();    <span class="comment">//"yoomin"，所有实例可以访问到原型对象的属性和方法</span></span><br></pre></td></tr></table></figure></p>
<p>所有原型对象都有一个constructor（构造函数）属性，Person.prototype.constructor指向Person。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert(Person.prototype.isPrototypeOf(person1));   <span class="comment">//true，判断Person.prototype是否是person1的原型对象</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert(<span class="built_in">Object</span>.getPrototypeOf(person1).name);   <span class="comment">//"yoomin"，getPrototypeOf用于取得Prototype的值，IE8及以下不支持</span></span><br></pre></td></tr></table></figure>
<p>也可以为实例重写属性，屏蔽原型对象的属性<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">person1.name = <span class="string">"yongming"</span>;</span><br><span class="line">alert(person1.name);   <span class="comment">//"yongming"，来自实例</span></span><br><span class="line">alert(person2.name);   <span class="comment">//"yoomin"，来自原型对象</span></span><br><span class="line"><span class="keyword">delete</span> person1.name;   <span class="comment">//可删除person1的name即"yongming"</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">alert(person1.hasOwnProperty(<span class="string">"name"</span>));   <span class="comment">//false，判断name属性是否存在于实例中，false表示该属性是从原型继承而来</span></span><br><span class="line">alert(<span class="string">"name"</span> <span class="keyword">in</span> person1);    <span class="comment">//true，通过对象能够访问name属性时则返回true，不管是实例的属性还是原型对象的属性</span></span><br></pre></td></tr></table></figure>
<p>同时使用<code>hasOwnProperty()</code>方法和<code>in</code>操作，可以确定该属性是在于于对象中，还是存在于原型中:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPrototypeProperty</span>(<span class="params">object, name</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !object.hasOwnProperty(name) &amp;&amp; (name <span class="keyword">in</span> object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>补充：</strong><code>for-in</code>循环返回的是所有能够通过对象访问的、可枚举的属性，包括实例中的和原型中的属性</p>
<p>更简单的原型语法，用一个对象字面量来重写整个原型对象，但constructor属性不再指向Person：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Person.prototype = &#123;</span><br><span class="line">	<span class="comment">//constructor: Person,     // 可直接指定constructor的值</span></span><br><span class="line">	name:<span class="string">"yoomin"</span>,</span><br><span class="line">	age:<span class="number">29</span>,</span><br><span class="line">	sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		alert(<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>修改原型对象中的属性的问题<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person, </span><br><span class="line">    name:"yoomin",</span><br><span class="line">    age:29,</span><br><span class="line">    friends:['Jay','Kelly'],   //原型对象中的属性</span><br><span class="line">    sayName: function() &#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.friends.push(<span class="string">'Jim'</span>);   <span class="comment">//给实例person1添加friends，修改将反映到原型对象中</span></span><br><span class="line"></span><br><span class="line">alert(person1.friends == person2.friends);  <span class="comment">//true，因为两个引用的都是原型对象中的friends数组</span></span><br></pre></td></tr></table></figure></p>
<p>组合使用构造函数模式和原型模式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造函数模式定义实例属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型模式定义方法和共享的属性</span></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">	<span class="keyword">constructor</span>:Person,</span><br><span class="line">	sayName:function() &#123;</span><br><span class="line">		alert(<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="【6-3-继承】"><a href="#【6-3-继承】" class="headerlink" title="【6.3 继承】"></a>【6.3 继承】</h5><ul>
<li>原型链</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承了SuperType，SuperType的实例赋给SubType的原型,拥有其全部属性和方法</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();  </span><br><span class="line"></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();   <span class="comment">// instance指向SubType的原型，SubType的原型指向SuperType的原型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// getSuperValue()方法仍在SuperType.prototype中，但property位于SubType.prototype中</span></span><br><span class="line">alert(instance.getSuperValue());  <span class="comment">//true，instance.constructor指向SuperType，因为被重写了</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>在使用原型链实现继承时，不能使用对象字面量创建原型方法：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();  <span class="comment">// 继承了SuperType</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处将重写prototype,上一句代码则失效了</span></span><br><span class="line">SubType.prototype = &#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>原型链问题：</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.colors = [<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承了SuperType，同时把SuperType的实便属性colors自身原型里的共享属性</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);   <span class="comment">// 此处直接修改SubType.prototype的colors，会反映在所有SubType的实例中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(instance2.colors);   <span class="comment">// "red,blue,green,black"</span></span><br></pre></td></tr></table></figure></p>
<p><strong>另一个问题：</strong> 在创建子类型的实例时，不能向超类型的构造函数中传递参数。</p>
<ul>
<li>借用构造函数</li>
</ul>
<p><strong>1.传递参数</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	SuperType.call(<span class="keyword">this</span>,<span class="string">"yoomin"</span>);   <span class="comment">// 继承同时传递参数</span></span><br><span class="line">	<span class="keyword">this</span>.age = <span class="number">29</span>;   <span class="comment">//实例属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>2.借用构造函数的问题</strong></p>
<p>方法都在构造函数中定义，因此函数复用无从谈起。</p>
<ul>
<li>组合继承</li>
</ul>
<p><strong>思路：</strong> 使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.colors = [<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">	SuperType.call(<span class="keyword">this</span>.name);   <span class="comment">// 继承属性</span></span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承方法</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.constructor = SubType;  <span class="comment">// 纠正constructor指向</span></span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>原型式继承</li>
</ul>
<p><strong>思路：</strong> 在object函数内部 ，先创建一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例。本质上讲是对传入其中的o执行了一次浅复制</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">	F.prototype = o;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>寄生式继承</li>
</ul>
<p><strong>思路：</strong>与工厂模式类似，即创建一个用于封闭继承过程的函数，该函数在内部以某种方式来增加对象，最后再像真地是它做了所有工作一样返回对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> clone = object(original);   <span class="comment">// 通过调用函数创建一个新对象 </span></span><br><span class="line">	clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;   <span class="comment">// 以某种方式来增加这个对象</span></span><br><span class="line">		alert(<span class="string">'hi'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> clone;   <span class="comment">// 返回这个对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> person = &#123;</span><br><span class="line"> name:<span class="string">"yoomin"</span>,</span><br><span class="line"> friends:[<span class="string">"shelby"</span>,<span class="string">"court"</span>,<span class="string">"van"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherPerson = createAnother(person);   <span class="comment">// anotherPerson是person加工后的</span></span><br><span class="line">anotherPerson.sayHi();   <span class="comment">//"hi"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>寄生组合式继承</li>
</ul>
<p>前面所讲的组合继承最大的问题是会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">	SuperType.call(<span class="keyword">this</span>,name);   <span class="comment">// 第二次调用SuperType()</span></span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType)();   <span class="comment">// 第一次调用SuperType()</span></span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong> 通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。不必为了指定子类型的原型而调用超类型的构造函数，我们需要的是超类型原型的一个副本而已。本质上，使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType,superType</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> prototype = object(superType.prototype);   <span class="comment">// 创建对象</span></span><br><span class="line">	prototype.constructor = subType;   <span class="comment">// 增强对象</span></span><br><span class="line">	subType.prototype = prototype;   <span class="comment">// 指定对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inheriPrototype(SubType,SuperType);  <span class="comment">// 调用</span></span><br></pre></td></tr></table></figure></p>
<p><strong>优点：</strong> 只调用了一次SuperType的构造函数，并且因此避免了在SubType.prototype上面创建不必要的属性，同时，原型链还能保持不变 ，因此还能正常使用instanceof和isPrototypeOf()，这是普遍认为最理想的继承方式</p>
<h4 id="七、函数表达式"><a href="#七、函数表达式" class="headerlink" title="七、函数表达式"></a>七、函数表达式</h4><hr>
<p>Firefox、Safari、Chrome和Opera都给函数定义了一个非标准的name属性，通过这个属性可以访问到给函数指定的名字。这个<br>属性的值永远等于跟在function关键字后面的标识符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//只在Firefox、Safari、Chrome和Opera有效</span></span><br><span class="line">alert(functionName.name); <span class="comment">//"functionName"</span></span><br></pre></td></tr></table></figure>
<p>第二种创建函数的方式是使用函数表达式。函数表达式有几种不同的语法形式。下面是最常见的一种形式。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> functionName = <span class="function"><span class="keyword">function</span>(<span class="params">arg0, arg1, arg2</span>)</span>&#123; </span><br><span class="line"><span class="comment">//函数体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这种形式看起来好像是常规的变量赋值语句，即创建一个函数并将它赋值给变量functionName。这种情况下创建的函数叫做匿名函数（anonymous function），因为function关键字后面没有标识符。（匿名函数有时候也叫拉姆达函数。）匿名函数的name属性是空字符串。</p>
<p>函数表达式与其他表达式一样，在使用前必须先赋值。以下代码会导致错误。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sayHi(); <span class="comment">//错误：函数还不存在</span></span><br><span class="line"><span class="keyword">var</span> sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">alert(<span class="string">"Hi!"</span>); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>理解函数提升的关键，就是理解函数声明与函数表达式之间的区别。例如，执行以下代码的结果可<br>能会让人意想不到。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不要这样做！</span></span><br><span class="line"><span class="keyword">if</span>(condition)&#123; </span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">		alert(<span class="string">"Hi!"</span>); </span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123; </span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">		alert(<span class="string">"Yo!"</span>); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，这在ECMAScript中属于无效语法，JavaScript引擎会尝试修正错误，将其转换为合理的状态。大多数浏览器会返回第二个声明，忽略condition；Firefox会在condition为true时返回第一个声明。不过，如果是使用函数表达式，那就没有什么问题了。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以这样做</span></span><br><span class="line"><span class="keyword">var</span> sayHi; </span><br><span class="line"><span class="keyword">if</span>(condition)&#123; </span><br><span class="line">	sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">		alert(<span class="string">"Hi!"</span>); </span><br><span class="line">	&#125;; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">	sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">		alert(<span class="string">"Yo!"</span>); </span><br><span class="line">	&#125;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="【7-1递归】"><a href="#【7-1递归】" class="headerlink" title="【7.1递归】"></a>【7.1递归】</h5><p>递归函数是在一个函数通过名字调用自身的情况下构成的，如下所示。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>)</span>&#123; </span><br><span class="line">	<span class="keyword">if</span> (num &lt;= <span class="number">1</span>)&#123; </span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">		<span class="keyword">return</span> num * factorial(num<span class="number">-1</span>); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是一个经典的递归阶乘函数。虽然这个函数表面看来没什么问题，但下面的代码却可能导致它出错。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> anotherFactorial = factorial; </span><br><span class="line">factorial = <span class="literal">null</span>; </span><br><span class="line">alert(anotherFactorial(<span class="number">4</span>)); <span class="comment">//出错！</span></span><br></pre></td></tr></table></figure></p>
<p>可以用它来实现对函数的递归调用，例如：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>)</span>&#123; </span><br><span class="line">	<span class="keyword">if</span> (num &lt;= <span class="number">1</span>)&#123; </span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">		<span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num<span class="number">-1</span>); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但在严格模式下，不能通过脚本访问arguments.callee，访问这个属性会导致错误。不过，可以使用命名函数表达式来达成相同的结果。例如：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> factorial = (<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">num</span>)</span>&#123; </span><br><span class="line">	<span class="keyword">if</span> (num &lt;= <span class="number">1</span>)&#123; </span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">		<span class="keyword">return</span> num * f(num<span class="number">-1</span>); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>以上代码创建了一个名为f()的命名函数表达式，然后将它赋值给变量factorial。即便把函数赋值给了另一个变量，函数的名字f仍然有效，所以递归调用照样能正确完成。这种方式在严格模式和非严格模式下都行得通。</p>
<h5 id="【7-2闭包】"><a href="#【7-2闭包】" class="headerlink" title="【7.2闭包】"></a>【7.2闭包】</h5><p><strong>闭包</strong> 是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span>(<span class="params">propertyName</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">object1, object2</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> value1 = object1[propertyName];</span><br><span class="line">		<span class="keyword">var</span> value2 = object2[propertyName];</span><br><span class="line">		<span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，突出的那两行代码是内部函数（一个匿名函数）中的代码，这两行代码访问了外部函数中的变量propertyName。即使这个内部函数被返回了，而且是在其他地方被调用了，但它仍然可以访问变量propertyName。之所以还能够访问这个变量，是因为内部函数的作用域链中包含createComparisonFunction()的作用域。</p>
<p>在函数执行过程中，为读取和写入变量的值，就需要在作用域链中查找变量。来看下面的例子。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = compare(<span class="number">5</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure></p>
<p>以上代码先定义了compare()函数，然后又在全局作用域中调用了它。当调用compare()时，会创建一个包含arguments、value1和value2 的活动对象。全局执行环境的变量对象（包含result和compare）在compare()执行环境的作用域链中则处于第二位。</p>
<p>后台的每个执行环境都有一个表示变量的对象——变量对象。全局环境的变量对象始终存在，而像compare()函数这样的局部环境的变量对象，则只在函数执行的过程中存在。在创建compare()函数时，会创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在内部的[[Scope]]属性中。当调用compare()函数时，会为函数创建一个执行环境，然后通过复制函数的[[Scope]]属性中的对象构建起执行环境的作用域链。此后，又有一个活动对象（在此作为变量对象使用）被创建并被推入执行环境作用域链的前端。对于这个例子中compare()函数的执行环境而言，其作用域链中包含两个变量对象：本地活动对象和全局变量对象。显然，作用域链本质上是一个指向变量对象的指针列表，它只<br>引用但不实际包含变量对象。</p>
<p>无论什么时候在函数中访问一个变量时，就会从作用域链中搜索具有相应名字的变量。一般来讲，<br>当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。<br>但是，闭包的情况又有所不同。</p>
<p>在另一个函数内部定义的函数会将包含函数（即外部函数）的活动对象添加到它的作用域链中。因此，在createComparisonFunction()函数内部定义的匿名函数的作用域链中，实际上将会包含外部函数createComparisonFunction()的活动对象。图7-2 展示了当下列代码执行时，包含函数与内部匿名函数的作用域链。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> compare = createComparisonFunction(<span class="string">"name"</span>);</span><br><span class="line"><span class="keyword">var</span> result = compare(&#123; name: <span class="string">"Nicholas"</span> &#125;, &#123; name: <span class="string">"Greg"</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>在匿名函数从createComparisonFunction()中被返回后，它的作用域链被初始化为包含createComparisonFunction()函数的活动对象和全局变量对象。这样，匿名函数就可以访问在createComparisonFunction()中定义的所有变量。更为重要的是，createComparisonFunction()函数在执行完毕后，其活动对象也不会被销毁，因为匿名函数的作用域链仍然在引用这个活动对象。换句话说，当createComparisonFunction()函数返回后，其执行环境的作用域链会被销毁，但它的活动对象仍然会留在内存中；直到匿名函数被销毁后，createComparisonFunction()的活动对象才会被销毁，例如：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建函数</span></span><br><span class="line"><span class="keyword">var</span> compareNames = createComparisonFunction(<span class="string">"name"</span>);</span><br><span class="line"><span class="comment">//调用函数</span></span><br><span class="line"><span class="keyword">var</span> result = compareNames(&#123; name: <span class="string">"Nicholas"</span> &#125;, &#123; name: <span class="string">"Greg"</span> &#125;);</span><br><span class="line"><span class="comment">//解除对匿名函数的引用（以便释放内存）</span></span><br><span class="line">compareNames = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></p>
<p>首先，创建的比较函数被保存在变量compareNames 中。而通过将compareNames 设置为等于null解除该函数的引用，就等于通知垃圾回收例程将其清除。随着匿名函数的作用域链被销毁，其他作用域（除了全局作用域）也都可以安全地销毁了。</p>
<ul>
<li>闭包与变量</li>
</ul>
<p>作用域链的这种配置机制引出了一个值得注意的副作用，即闭包只能取得包含函数中任何变量的最后一个值。别忘了闭包所保存的是整个变量对象，而不是某个特殊的变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		result[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个函数都返回10。因为每个函数的作用域链中都保存着createFunctions() 函数的活动对象， 所以它们引用的都是同一个变量i 。当createFunctions()函数返回后，变量i 的值是10，此时每个函数都引用着保存变量i 的同一个变量对象，所以在每个函数内部i 的值都是10。但是，我们可以通过创建另一个匿名函数强制让闭包的行为符合预期，如下所示。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		result[i] = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> num;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>关于this对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">	name: <span class="string">"My Object"</span>,</span><br><span class="line">	getNameFunc: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">alert(object.getNameFunc()()); <span class="comment">//"The Window"（在非严格模式下）</span></span><br></pre></td></tr></table></figure>
<p>由于getNameFunc()返回一个函数，因此调用object.getNameFunc()()就会立即调用它返回的函数，结果就是返回一个字符串。</p>
<p>前面曾经提到过，每个函数在被调用时都会自动取得两个特殊变量：this 和arguments。内部函数在搜索这两个变量时，只会搜索到其活动对象为止，因此永远不可能直接访问外部函数中的这两个变量。不过，把外部作用域中的this对象保存在一个闭包能够访问到的变量里，就可以让闭包访问该对象了，如下所示。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">	name: <span class="string">"My Object"</span>,</span><br><span class="line">	getNameFunc: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> that.name;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">alert(object.getNameFunc()()); <span class="comment">//"My Object"</span></span><br></pre></td></tr></table></figure>
<p>在定义匿名函数之前，我们把this对象赋值给了一个名叫that的变量。而在定义了闭包之后，闭包也可以访问这个变量，因为它是我们在包含函数中特意声名的一个变量。即使在函数返回之后，that 也仍然引用着object，所以调用object.getNameFunc()()就返回了”My Object”。</p>
<p><strong>注意：</strong>this和arguments也存在同样的问题。如果想访问作用域中的arguments对象，必须将对该对象的引用保存到另一个闭包能够访问的变量中。</p>
<p>改变this的值：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">	name: <span class="string">"My Object"</span>,</span><br><span class="line">	getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">object.getName(); <span class="comment">//"My Object"</span></span><br><span class="line">(object.getName)(); <span class="comment">//"My Object"</span></span><br><span class="line">(object.getName = object.getName)(); <span class="comment">//"The Window"，在非严格模式下</span></span><br></pre></td></tr></table></figure></p>
<p>第一行代码跟平常一样调用了object.getName()，返回的是”My Object”，因为this.name就是object.name。第二行代码在调用这个方法前先给它加上了括号。虽然加上括号之后，就好像只是在引用一个函数，但this的值得到了维持，因为object.getName 和(object.getName)的定义是相同的。第三行代码先执行了一条赋值语句，然后再调用赋值后的结果。因为这个赋值表达式的值是函数本身，所以this的值不能得到维持，结果就返回了”The Window”。</p>
<p>当然，你不大可能会像第二行和第三行代码一样调用这个方法。不过，这个例子有助于说明即使是<br>语法的细微变化，都有可能意外改变this 的值。</p>
<ul>
<li>内存泄漏</li>
</ul>
<p>由于IE9 之前的版本对JScript 对象和COM 对象使用不同的垃圾收集例程，如果闭包的作用域链中保存着一个HTML 元素，那么就意味着该元素将无法被销毁。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignHandler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"someElement"</span>);</span><br><span class="line">	element.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		alert(element.id);</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上代码创建了一个作为element 元素事件处理程序的闭包，而这个闭包则又创建了一个循环引用（事件将在第13章讨论）。由于匿名函数保存了一个对assignHandler()的活动对象的引用，因此就会导致无法减少element 的引用数。只要匿名函数存在，element的引用数至少也是1，因此它所占用的内存就永远不会被回收。不过，这个问题可以通过稍微改写一下代码来解决，如下所示。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignHandler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"someElement"</span>);</span><br><span class="line">	<span class="keyword">var</span> id = element.id;</span><br><span class="line">	element.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		alert(id);</span><br><span class="line">	&#125;;</span><br><span class="line">	element = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上面的代码中，通过把element.id 的一个副本保存在一个变量中，并且在闭包中引用该变量消除了循环引用。但仅仅做到这一步，还是不能解决内存泄漏的问题。必须要记住：闭包会引用包含函数的整个活动对象，而其中包含着element。即使闭包不直接引用element，包含函数的活动对象中也仍然会保存一个引用。因此，有必要把element变量设置为null。这样就能够解除对DOM对象的引用，顺利地减少其引用数，确保正常回收其占用的内存。</p>
<h5 id="【7-3模仿块级作用域】"><a href="#【7-3模仿块级作用域】" class="headerlink" title="【7.3模仿块级作用域】"></a>【7.3模仿块级作用域】</h5><p>在Java、C++等语言中，变量i只会在for 循环的语句块中有定义，循环一旦结束，变量i就会被销毁。可是在JavaScrip中，变量i是定义在ouputNumbers()的活动对象中的。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outputNumbers</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> i; <span class="comment">//重新声明变量，被无视</span></span><br><span class="line">	alert(i); <span class="comment">//5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>JavaScript 从来不会告诉你是否多次声明了同一个变量；遇到这种情况，它只会对后续的声明视而不见（不过，它会执行后续声明中的变量初始化）。匿名函数可以用来模仿块级作用域并避免这个问题。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">//这里是块级作用域</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p>
<p>然而，下面的代码却会导致错误。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">//这里是块级作用域</span></span><br><span class="line">&#125;(); <span class="comment">//出错！</span></span><br></pre></td></tr></table></figure></p>
<p>这段代码会导致语法错误，是因为JavaScript将function关键字当作一个函数声明的开始，而函数声明后面不能跟圆括号。然而，函数表达式的后面可以跟圆括号。</p>
<h5 id="【7-4私有变量】"><a href="#【7-4私有变量】" class="headerlink" title="【7.4私有变量】"></a>【7.4私有变量】</h5><p>如果在这个函数内部创建一个闭包，那么闭包通过自己的作用域链也可以访问这些变量。而利用这一点，就可以创建用于访问私有变的公有方法。我们把有权访问私有变量和私有函数的公有方法称为特权方法（privileged method）。有两种在对象上创建特权方法的方式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyObject</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">//私有变量和私有函数</span></span><br><span class="line">	<span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//特权方法</span></span><br><span class="line">	<span class="keyword">this</span>.publicMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		privateVariable++;</span><br><span class="line">		<span class="keyword">return</span> privateFunction();</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>静态私有变量</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">//私有变量和私有函数</span></span><br><span class="line">	<span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//构造函数，未加var，是全局变量</span></span><br><span class="line">	MyObject = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//公有/特权方法</span></span><br><span class="line">	MyObject.prototype.publicMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		privateVariable++;</span><br><span class="line">		<span class="keyword">return</span> privateFunction();</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>这个模式在定义构造函数时并没有使用函数声明，而是使用了函数表达式。函数声明只能创建局部函数，但那并不是我们想要的。</p>
<ul>
<li>模块模式</li>
</ul>
<p>而道格拉斯所说的模块模式（module<br>pattern）则是为单例创建私有变量和特权方法。所谓单例（singleton），指的就是只有一个实例的对象。按照惯例，JavaScript是以对象字面量的方式来创建单例对象的。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> singleton = &#123;</span><br><span class="line">	name: value,</span><br><span class="line">	method: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="comment">//这里是方法的代码</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>模块模式通过为单例添加私有变量和特权方法能够使其得到增强，其语法形式如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> singleton = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">//私有变量和私有函数</span></span><br><span class="line">	<span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//特权/公有方法和属性</span></span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		publicProperty: <span class="literal">true</span>,</span><br><span class="line">		publicMethod: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			privateVariable++;</span><br><span class="line">			<span class="keyword">return</span> privateFunction();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure></p>
<p>返回的对象字面量中只包含可以公开的属性和方法。由于这个对象是在匿名函数内部定义的，因此它的公有方法有权访问私有变量和函数。</p>
<p>从本质上来讲，这个对象字面量定义的是单例的公共接口。这种模式在需要对单例进行某些初始化，同时又需要维护其私有变量时是非常有用的，例如：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> application = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">//私有变量和函数</span></span><br><span class="line">	<span class="keyword">var</span> components = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">	<span class="comment">//初始化，需要关心BaseComponent 的代码</span></span><br><span class="line">	components.push(<span class="keyword">new</span> BaseComponent());</span><br><span class="line">	<span class="comment">//公共</span></span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		getComponentCount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> components.length;</span><br><span class="line">		&#125;,</span><br><span class="line">		registerComponent: <span class="function"><span class="keyword">function</span>(<span class="params">component</span>) </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">typeof</span> component == <span class="string">"object"</span>) &#123;</span><br><span class="line">				components.push(component);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure></p>
<p>返回对象的getComponentCount()和registerComponent()方法，都是有权访问数组components的特权方法。前者只是返回已注册的组件数目，后者用于注册新组件。</p>
<ul>
<li>增强的模块模式</li>
</ul>
<p>这种增强的模块模式适合那些单例必须是某种类型的实例，同时还必须添加某些属性和（或）方法对其加以增强的情况。来看下面的例子。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> singleton = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">//私有变量和私有函数</span></span><br><span class="line">	<span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//创建对象</span></span><br><span class="line">	<span class="keyword">var</span> object = <span class="keyword">new</span> CustomType();</span><br><span class="line">	<span class="comment">//添加特权/公有属性和方法</span></span><br><span class="line">	object.publicProperty = <span class="literal">true</span>;</span><br><span class="line">	object.publicMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		privateVariable++;</span><br><span class="line">		<span class="keyword">return</span> privateFunction();</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">//返回这个对象</span></span><br><span class="line">	<span class="keyword">return</span> object;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure></p>
<p>如果前面演示模块模式的例子中的application 对象必须是BaseComponent 的实例，那么就可以使用以下代码。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> application = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">//私有变量和函数</span></span><br><span class="line">	<span class="keyword">var</span> components = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">	<span class="comment">//初始化</span></span><br><span class="line">	components.push(<span class="keyword">new</span> BaseComponent());</span><br><span class="line">	<span class="comment">//创建application 的一个局部副本</span></span><br><span class="line">	<span class="keyword">var</span> app = <span class="keyword">new</span> BaseComponent();</span><br><span class="line">	<span class="comment">//公共接口</span></span><br><span class="line">	app.getComponentCount = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> components.length;</span><br><span class="line">	&#125;;</span><br><span class="line">	app.registerComponent = <span class="function"><span class="keyword">function</span>(<span class="params">component</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">typeof</span> component == <span class="string">"object"</span>) &#123;</span><br><span class="line">			components.push(component);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">//返回这个副本</span></span><br><span class="line">	<span class="keyword">return</span> app;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure></p>
<p>在这个重写后的应用程序（application）单例中，首先也是像前面例子中一样定义了私有变量。主要的不同之处在于命名变量app的创建过程，因为它必须是BaseComponent 的实例。这个实例实际上是application对象的局部变量版。此后，我们又为app对象添加了能够访问私有变量的公有方法。最后一步是返回app 对象，结果仍然是将它赋值给全局变量application。</p>
<h4 id="八、BOM"><a href="#八、BOM" class="headerlink" title="八、BOM"></a>八、BOM</h4><hr>
<h5 id="【8-1-window对象】"><a href="#【8-1-window对象】" class="headerlink" title="【8.1 window对象】"></a>【8.1 window对象】</h5><p>抛开全局变量会成为window对象的属性不谈，定义全局变量与在window对象上直接定义属性还是有一点差别：全局变量不能通过delete操作符删除，而直接在window对象上的定义的属性可以。<br>例如：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">29</span>;</span><br><span class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</span><br><span class="line"><span class="comment">//在IE &lt; 9 时抛出错误，在其他所有浏览器中都返回false</span></span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">window</span>.age;</span><br><span class="line"><span class="comment">//在IE &lt; 9 时抛出错误，在其他所有浏览器中都返回true</span></span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">window</span>.color; <span class="comment">//returns true</span></span><br><span class="line">alert(<span class="built_in">window</span>.age); <span class="comment">//29</span></span><br><span class="line">alert(<span class="built_in">window</span>.color); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure></p>
<p>刚才使用var 语句添加的window 属性有一个名为[[Configurable]]的特性，这个特性的值被设置为false，因此这样定义的属性不可以通过delete 操作符删除。IE8及更早版本在遇到使用delete删除window属性的语句时，不管该属性最初是如何创建的，都会抛出错误，以示警告。IE9 及更高版本不会抛出错误。</p>
<p>另外，还要记住一件事：尝试访问未声明的变量会抛出错误，但是通过查询window 对象，可以知<br>道某个可能未声明的变量是否存在。例如：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里会抛出错误，因为oldValue 未定义</span></span><br><span class="line"><span class="keyword">var</span> newValue = oldValue;</span><br><span class="line"><span class="comment">//这里不会抛出错误，因为这是一次属性查询</span></span><br><span class="line"><span class="comment">//newValue 的值是undefined</span></span><br><span class="line"><span class="keyword">var</span> newValue = <span class="built_in">window</span>.oldValue;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>窗口与框架</li>
</ul>
<p>与框架有关的最后一个对象是self，它始终指向window；实际上，self 和window 对象可以互换使用。</p>
<ul>
<li>窗口位置</li>
</ul>
<p>IE、Safari、Opera和Chrome都提供了screenLeft和screenTop属性，分别用于表示窗口相对于屏幕左边和上边的位置。Firefox则在screenX 和screenY属性中提供相同的窗口位置信息，Safari和Chrome也同时支持这两个属性。使用下列代码可以跨浏览器取得窗口左边和上边的位置。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> leftPos = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenLeft == <span class="string">"number"</span>) ?</span><br><span class="line">	<span class="built_in">window</span>.screenLeft : <span class="built_in">window</span>.screenX;</span><br><span class="line"><span class="keyword">var</span> topPos = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenTop == <span class="string">"number"</span>) ?</span><br><span class="line">	<span class="built_in">window</span>.screenTop : <span class="built_in">window</span>.screenY;</span><br></pre></td></tr></table></figure></p>
<p>这个例子运用二元操作符首先确定screenLeft 和screenTop 属性是否存在，如果是（在IE、<br>Safari、Opera 和Chrome 中），则取得这两个属性的值。如果不存在（在Firefox 中），则取得screenX<br>和screenY 的值。</p>
<p>在IE、Opera 中，screenLeft 和screenTop 中保存<br>的是从屏幕左边和上边到由window 对象表示的页面可见区域的距离。换句话说，如果window 对象是<br>最外层对象，而且浏览器窗口紧贴屏幕最上端——即y 轴坐标为0，那么screenTop 的值就是位于页面<br>可见区域上方的浏览器工具栏的像素高度。但是，在Chrome、Firefox 和Safari 中，screenY 或screenTop<br>中保存的是整个浏览器窗口相对于屏幕的坐标值，即在窗口的y 轴坐标为0 时返回0。</p>
<p>更让人捉摸不透是，Firefox、Safari 和Chrome 始终返回页面中每个框架的top.screenX 和<br>top.screenY 值。即使在页面由于被设置了外边距而发生偏移的情况下，相对于window 对象使用<br>screenX 和screenY 每次也都会返回相同的值。而IE 和Opera 则会给出框架相对于屏幕边界的精确坐<br>标值。</p>
<p>最终结果，就是无法在跨浏览器的条件下取得窗口左边和上边的精确坐标值。然而，使用moveTo()<br>和moveBy()方法倒是有可能将窗口精确地移动到一个新位置。这两个方法都接收两个参数，其中moveTo()接收的是新位置的x 和y 坐标值，而moveBy()接收的是在水平和垂直方向上移动的像素数。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将窗口移动到(200,300)</span></span><br><span class="line"><span class="built_in">window</span>.moveTo(<span class="number">200</span>,<span class="number">300</span>);</span><br><span class="line"><span class="comment">//将窗口向左移动50 像素</span></span><br><span class="line"><span class="built_in">window</span>.moveBy(<span class="number">-50</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<ul>
<li>窗口大小</li>
</ul>
<p>虽然最终无法确定浏览器窗口本身的大小，但却可以取得页面视口的大小，如下所示。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pageWidth = <span class="built_in">window</span>.innerWidth,</span><br><span class="line">	pageHeight = <span class="built_in">window</span>.innerHeight;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> pageWidth != <span class="string">"number"</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">document</span>.compatMode == <span class="string">"CSS1Compat"</span>) &#123;</span><br><span class="line">		pageWidth = <span class="built_in">document</span>.documentElement.clientWidth;</span><br><span class="line">		pageHeight = <span class="built_in">document</span>.documentElement.clientHeight;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		pageWidth = <span class="built_in">document</span>.body.clientWidth;</span><br><span class="line">		pageHeight = <span class="built_in">document</span>.body.clientHeight;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在以上代码中，我们首先将window.innerWidth 和window.innerHeight 的值分别赋给了<br>pageWidth 和pageHeight。然后检查pageWidth 中保存的是不是一个数值；如果不是，则通过检查<br>document.compatMode（这个属性将在第10 章全面讨论）来确定页面是否处于标准模式。如果是，则<br>分别使用document.documentElement.clientWidth 和document.documentElement.client-<br>Height 的值。否则，就使用document.body.clientWidth 和document.body.clientHeight 的值。</p>
<p>另外，使用resizeTo()和resizeBy()方法可以调整浏览器窗口的大小。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调整到100×100</span></span><br><span class="line"><span class="built_in">window</span>.resizeTo(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"><span class="comment">//调整到200×150</span></span><br><span class="line"><span class="built_in">window</span>.resizeBy(<span class="number">100</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，这两个方法与移动窗口位置的方法类似，也有可能被浏览器禁用；而且，在Opera<br>和IE7（及更高版本）中默认就是禁用的。另外，这两个方法同样不适用于框架，而只能对最外层的<br>window 对象使用。</p>
<ul>
<li>导航和打开窗口</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.open(<span class="string">"http://www.wrox.com/"</span>, <span class="string">"wroxWindow"</span>,<span class="string">"height=400,width=400,top=10,left=10,resizable=yes"</span>);</span><br></pre></td></tr></table></figure>
<p>这行代码会打开一个新的可以调整大小的窗口，窗口初始大小为400×400 像素，并且距屏幕上沿<br>和左边各10 像素。</p>
<p>window.open()方法会返回一个指向新窗口的引用。引用的对象与其他window 对象大致相似，但<br>我们可以对其进行更多控制。例如，有些浏览器在默认情况下可能不允许我们针对主浏览器窗口调整大<br>小或移动位置，但却允许我们针对通过window.open()创建的窗口调整大小或移动位置。通过这个返<br>回的对象，可以像操作其他窗口一样操作新打开的窗口，如下所示。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> wroxWin = <span class="built_in">window</span>.open(<span class="string">"http://www.wrox.com/"</span>, <span class="string">"wroxWindow"</span>,</span><br><span class="line">	<span class="string">"height=400,width=400,top=10,left=10,resizable=yes"</span>);</span><br><span class="line"><span class="comment">//调整大小</span></span><br><span class="line">wroxWin.resizeTo(<span class="number">500</span>, <span class="number">500</span>);</span><br><span class="line"><span class="comment">//移动位置</span></span><br><span class="line">wroxWin.moveTo(<span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>调用close()方法还可以关闭新打开的窗口。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">wroxWin.close();</span><br></pre></td></tr></table></figure></p>
<p>但是，这个方法仅适用于通过window.open()打开的弹出窗口。对于浏览器的主窗口，如果没有<br>得到用户的允许是不能关闭它的。不过，弹出窗口倒是可以调用top.close()在不经用户允许的情况<br>下关闭自己。</p>
<p>新创建的window 对象有一个opener 属性，其中保存着打开它的原始窗口对象。这个属性只在弹出<br>窗口中的最外层window 对象（top）中有定义，而且指向调用window.open()的窗口或框架。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> wroxWin = <span class="built_in">window</span>.open(<span class="string">"http://www.wrox.com/"</span>, <span class="string">"wroxWindow"</span>, <span class="string">"height=400,width=400,top=10,left=10,resizable=yes"</span>);</span><br><span class="line">alert(wroxWin.opener == <span class="built_in">window</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>虽然弹出窗口中有一个指针指向打开它的原始窗口，但原始窗口中并没有这样的指针指向弹出窗<br>口。如果两个window 对象之间需要彼此通信，那么新标签页就不能运行在独立的进程中。在Chrome<br>中，将新创建的标签页的opener 属性设置为null，即表示在单独的进程中运行新标签页，如下所示。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> wroxWin = <span class="built_in">window</span>.open(<span class="string">"http://www.wrox.com/"</span>, <span class="string">"wroxWindow"</span>, <span class="string">"height=400,width=400,top=10,left=10,resizable=yes"</span>);</span><br><span class="line">wroxWin.opener = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>如果是浏览器内置的屏蔽程序阻止的弹出窗口，那<br>么window.open()很可能会返回null。如果是浏览器扩展或其他程序阻止的弹出窗口，那么window.open()通常会抛出一个错误。因此，<br>要想准确地检测出弹出窗口是否被屏蔽，必须在检测返回值的同时，将对window.open()的调用封装<br>在一个try-catch 块中，如下所示。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> blocked = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wroxWin = <span class="built_in">window</span>.open(<span class="string">"http://www.wrox.com"</span>, <span class="string">"_blank"</span>);</span><br><span class="line">	<span class="keyword">if</span> (wroxWin == <span class="literal">null</span>) &#123;</span><br><span class="line">		blocked = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">	blocked = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (blocked) &#123;</span><br><span class="line">	alert(<span class="string">"The popup was blocked!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>间歇调用和超时调用</li>
</ul>
<p>JavaScript 是单线程语言，但它允许通过设置超时值和间歇时间值来调度代码在特定的时刻执行。<br>前者是在指定的时间过后执行代码，而后者则是每隔指定的时间就执行一次代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不建议传递字符串，会导致性能损失</span></span><br><span class="line">setTimeout(<span class="string">"alert('Hello world!') "</span>, <span class="number">1000</span>);</span><br><span class="line"><span class="comment">//推荐的调用方式</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">alert(<span class="string">"Hello world!"</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>超时调用的代码都是在全局作用域中执行的，因此函数中this 的值在非严格模<br>式下指向window 对象，在严格模式下是undefined。</p>
<p>以下是一个常见的使用间歇调用的例子。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> max = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> intervalId = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incrementNumber</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	num++;</span><br><span class="line">	<span class="comment">//如果执行次数达到了max 设定的值，则取消后续尚未执行的调用</span></span><br><span class="line">	<span class="keyword">if</span> (num == max) &#123;</span><br><span class="line">		clearInterval(intervalId);</span><br><span class="line">		alert(<span class="string">"Done"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">intervalId = setInterval(incrementNumber, <span class="number">500</span>);</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，变量num 每半秒钟递增一次，当递增到最大值时就会取消先前设定的间歇调用。这<br>个模式也可以使用超时调用来实现，如下所示。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> max = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incrementNumber</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	num++;</span><br><span class="line">	<span class="comment">//如果执行次数未达到max 设定的值，则设置另一次超时调用</span></span><br><span class="line">	<span class="keyword">if</span> (num &lt; max) &#123;</span><br><span class="line">		setTimeout(incrementNumber, <span class="number">500</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		alert(<span class="string">"Done"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(incrementNumber, <span class="number">500</span>);</span><br></pre></td></tr></table></figure>
<p>在开<br>发环境下，很少使用真正的间歇调用，原因是后一个间歇调用可能会在前一个间歇调用结束之前启动。<br>而像前面示例中那样使用超时调用，则完全可以避免这一点。所以，最好不要使用间歇调用。</p>
<h5 id="8-2-location对象】"><a href="#8-2-location对象】" class="headerlink" title="8.2 location对象】"></a>8.2 location对象】</h5><ul>
<li>查询字符串参数</li>
</ul>
<p>。尽管location.search 返回从问号到URL 末尾的所有内容，但却没有办法逐个<br>访问其中的每个查询字符串参数。以下方法用于解析字符串：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getQueryStringArgs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">//取得查询字符串并去掉开头的问号</span></span><br><span class="line">	<span class="keyword">var</span> qs = (location.search.length &gt; <span class="number">0</span> ? location.search.substring(<span class="number">1</span>) : <span class="string">""</span>),</span><br><span class="line">		<span class="comment">//保存数据的对象</span></span><br><span class="line">		args = &#123;&#125;,</span><br><span class="line">		<span class="comment">//取得每一项</span></span><br><span class="line">		items = qs.length ? qs.split(<span class="string">"&amp;"</span>) : [],</span><br><span class="line">		item = <span class="literal">null</span>,</span><br><span class="line">		name = <span class="literal">null</span>,</span><br><span class="line">		value = <span class="literal">null</span>,</span><br><span class="line">		<span class="comment">//在for 循环中使用</span></span><br><span class="line">		i = <span class="number">0</span>,</span><br><span class="line">		len = items.length;</span><br><span class="line">	<span class="comment">//逐个将每一项添加到args 对象中</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		item = items[i].split(<span class="string">"="</span>);</span><br><span class="line">		name = <span class="built_in">decodeURIComponent</span>(item[<span class="number">0</span>]);</span><br><span class="line">		value = <span class="built_in">decodeURIComponent</span>(item[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">if</span> (name.length) &#123;</span><br><span class="line">			args[name] = value;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>位置操作</li>
</ul>
<p>下面的例子展示了通过将hash、<br>search、hostname、pathname 和port 属性设置为新值来改变URL。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//假设初始URL 为http://www.wrox.com/WileyCDA/</span></span><br><span class="line"><span class="comment">//将URL 修改为"http://www.wrox.com/WileyCDA/#section1"</span></span><br><span class="line">location.hash = <span class="string">"#section1"</span>;</span><br><span class="line"><span class="comment">//将URL 修改为"http://www.wrox.com/WileyCDA/?q=javascript"</span></span><br><span class="line">location.search = <span class="string">"?q=javascript"</span>;</span><br><span class="line"><span class="comment">//将URL 修改为"http://www.yahoo.com/WileyCDA/"</span></span><br><span class="line">location.hostname = <span class="string">"www.yahoo.com"</span>;</span><br><span class="line"><span class="comment">//将URL 修改为"http://www.yahoo.com/mydir/"</span></span><br><span class="line">location.pathname = <span class="string">"mydir"</span>;</span><br><span class="line"><span class="comment">//将URL 修改为"http://www.yahoo.com:8080/WileyCDA/"</span></span><br><span class="line">location.port = <span class="number">8080</span>;</span><br></pre></td></tr></table></figure></p>
<p>在IE8、Firefox 1、Safari 2+、Opera 9+和Chrome 中，修改hash 的值会在浏览<br>器的历史记录中生成一条新记录。</p>
<p>在调用replace()方法之后，用户不能回到前一个页面。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">location.replace(<span class="string">"http://www.wrox.com/"</span>);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">location.reload(); <span class="comment">//重新加载（有可能从缓存中加载）</span></span><br><span class="line">location.reload(<span class="literal">true</span>); <span class="comment">//重新加载（从服务器重新加载）</span></span><br></pre></td></tr></table></figure>
<p>位于reload()调用之后的代码可能会也可能不会执行，这要取决于网络延迟或系统资源等因素。<br>为此，最好将reload()放在代码的最后一行。</p>
<h5 id="【8-3-navigation对象】"><a href="#【8-3-navigation对象】" class="headerlink" title="【8.3 navigation对象】"></a>【8.3 navigation对象】</h5><ul>
<li>检测插件<br>对于非IE 浏览器，可以使用<br>plugins 数组来达到这个目的。该数组中的每一项都包含下列属性。</li>
</ul>
<p> name：插件的名字。<br> description：插件的描述。<br> filename：插件的文件名。<br> length：插件所处理的MIME 类型数量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//检测插件（在IE 中无效）</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">hasPlugin</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">		name = name.toLowerCase();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; navigator.plugins.length; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (navigator.plugins[i].name.toLowerCase().indexOf(name) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//检测Flash</span></span><br><span class="line">	alert(hasPlugin(<span class="string">"Flash"</span>));</span><br><span class="line">	<span class="comment">//检测QuickTime</span></span><br><span class="line">	alert(hasPlugin(<span class="string">"QuickTime"</span>));</span><br></pre></td></tr></table></figure>
<p>在IE 中检测插件的唯一方式就是<br>使用专有的ActiveXObject 类型，并尝试创建一个特定插件的实例。IE 是以COM对象的方式实现插<br>件的，而COM对象使用唯一标识符来标识。因此，要想检查特定的插件，就必须知道其COM标识符。<br>例如，Flash 的标识符是ShockwaveFlash.ShockwaveFlash。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//检测IE 中的插件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasIEPlugin</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">new</span> ActiveXObject(name);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检测Flash</span></span><br><span class="line">alert(hasIEPlugin(<span class="string">"ShockwaveFlash.ShockwaveFlash"</span>));</span><br><span class="line"><span class="comment">//检测QuickTime</span></span><br><span class="line">alert(hasIEPlugin(<span class="string">"QuickTime.QuickTime"</span>));</span><br></pre></td></tr></table></figure>
<h5 id="【8-4screen对象】"><a href="#【8-4screen对象】" class="headerlink" title="【8.4screen对象】"></a>【8.4screen对象】</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.resizeTo(screen.availWidth, screen.availHeight);  <span class="comment">//使窗口满屏</span></span><br></pre></td></tr></table></figure>
<h5 id="【8-5-history对象】"><a href="#【8-5-history对象】" class="headerlink" title="【8.5 history对象】"></a>【8.5 history对象】</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//后退一页</span></span><br><span class="line">history.go(<span class="number">-1</span>);</span><br><span class="line"><span class="comment">//前进一页</span></span><br><span class="line">history.go(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//跳转到最近的wrox.com 页面</span></span><br><span class="line">history.go(<span class="string">"wrox.com"</span>);</span><br><span class="line"><span class="comment">//跳转到最近的nczonline.net 页面</span></span><br><span class="line">history.go(<span class="string">"nczonline.net"</span>);</span><br><span class="line"><span class="comment">//后退一页</span></span><br><span class="line">history.back();</span><br><span class="line"><span class="comment">//前进一页</span></span><br><span class="line">history.forward();</span><br></pre></td></tr></table></figure>
<p>通过像下面这样测试该属性的值，可以确定用户是否一开始就打开了你的<br>页面。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (history.length == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//这应该是用户打开窗口后的第一个页面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="九、客户端检测"><a href="#九、客户端检测" class="headerlink" title="九、客户端检测"></a>九、客户端检测</h4><hr>
<h5 id="【9-1-能力检测】"><a href="#【9-1-能力检测】" class="headerlink" title="【9.1 能力检测】"></a>【9.1 能力检测】</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不要这样做！这不是能力检测——只检测了是否存在相应的方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isSortable</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !!object.sort;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数通过检测对象是否存在sort()方法，来确定对象是否支持排序。问题是，任何包含sort<br>属性的对象也会返回true。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这样更好：检查sort 是不是函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isSortable</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">typeof</span> object.sort == <span class="string">"function"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>大多数浏览器在检测到document.createElement()<br>存在时，都会返回true。除了IE<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在IE8 及之前版本中不行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasCreateElement</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">typeof</span> <span class="built_in">document</span>.createElement == <span class="string">"function"</span>;   <span class="comment">//IE8中的是object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在IE 中会导致错误</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHttp"</span>);</span><br><span class="line"><span class="keyword">if</span> (xhr.open) &#123; <span class="comment">//这里会发生错误</span></span><br><span class="line">	<span class="comment">//执行操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像这样直接把函数作为属性访问会导致JavaScript 错误。使用typeof 操作符会更靠谱一点，但IE<br>对typeof xhr.open 会返回”unknown”。比较兼容的做法：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isHostMethod</span>(<span class="params">object, property</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> t = <span class="keyword">typeof</span> object[property];</span><br><span class="line">	<span class="keyword">return</span> t == <span class="string">'function'</span> ||</span><br><span class="line">		(!!(t == <span class="string">'object'</span> &amp;&amp; object[property])) ||</span><br><span class="line">		t == <span class="string">'unknown'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result = isHostMethod(xhr, <span class="string">"open"</span>); <span class="comment">//true</span></span><br><span class="line">result = isHostMethod(xhr, <span class="string">"foo"</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure></p>
<h5 id="【9-2-怪僻检测】"><a href="#【9-2-怪僻检测】" class="headerlink" title="【9.2 怪僻检测】"></a>【9.2 怪僻检测】</h5><p>与能力检测类似，怪癖检测（quirks detection）的目标是识别浏览器的特殊行为。<br>IE8 及更早版本中存在一个bug，即如果<br>某个实例属性与[[Enumerable]]标记为false 的某个原型属性同名，那么该实例属性将不会出现在<br>fon-in 循环当中。检测如下<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hasDontEnumQuirk = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> o = &#123;</span><br><span class="line">		toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> o) &#123;</span><br><span class="line">		<span class="keyword">if</span> (prop == <span class="string">"toString"</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure></p>
<h5 id="【9-3-用户代理检测】"><a href="#【9-3-用户代理检测】" class="headerlink" title="【9.3 用户代理检测】"></a>【9.3 用户代理检测】</h5><p>（此章篇幅较长，涉及移动端，跳过）</p>
<h4 id="十、DOM"><a href="#十、DOM" class="headerlink" title="十、DOM"></a>十、DOM</h4><hr>
<p>注意，IE 中的所有DOM 对象都是以COM 对象的形式实现的。这意味着IE 中的<br>DOM 对象与原生JavaScript 对象的行为或活动特点并不一致。</p>
<h5 id="【10-1-节点层次】"><a href="#【10-1-节点层次】" class="headerlink" title="【10.1 节点层次】"></a>【10.1 节点层次】</h5><p>文档节点是每个文档的根节点。在这个例子中，文档节点只有一个子节点，即<html>元素，我们称之为文档元素。<br>HTML 元素通过元素节点表示，特性（attribute）<br>通过特性节点表示，文档类型通过文档类型节点表示，而注释则通过注释节点表示。总共有12 种节点<br>类型，这些类型都继承自一个基类型。</html></p>
<ul>
<li>Node类型</li>
</ul>
<p>每个节点都有一个nodeType 属性，用于表明节点的类型。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (someNode.nodeType == Node.ELEMENT_NODE) &#123; <span class="comment">//在IE 中无效</span></span><br><span class="line">	alert(<span class="string">"Node is an element."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个例子比较了someNode.nodeType 与Node.ELEMENT_NODE 常量。如果二者相等，则意味着<br>someNode 确实是一个元素。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (someNode.nodeType == <span class="number">1</span>) &#123; <span class="comment">//适用于所有浏览器</span></span><br><span class="line">	alert(<span class="string">"Node is an element."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于元素节点，nodeName 中保存的始终都是元素的标签名，而nodeValue 的值则始终为null，文件节点的nodeValue是其内容。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> firstChild = someNode.childNodes[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> secondChild = someNode.childNodes.item(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
<p>我们在本书前面介绍过，对arguments 对象使用Array.prototype.slice()方法可以<br>将其转换为数组。而采用同样的方法，也可以将NodeList 对象转换为数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在IE8 及之前版本中无效</span></span><br><span class="line"><span class="keyword">var</span> arrayOfNodes = <span class="built_in">Array</span>.prototype.slice.call(someNode.childNodes,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>要想在IE 中将NodeList 转换为数组，必须手动枚举所有成员。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">convertToArray</span>(<span class="params">nodes</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> array = <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		array = <span class="built_in">Array</span>.prototype.slice.call(nodes, <span class="number">0</span>); <span class="comment">//针对非IE 浏览器</span></span><br><span class="line">	&#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">		array = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = nodes.length; i &lt; len; i++) &#123;</span><br><span class="line">			array.push(nodes[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>hasChildNodes()也是一个非常有用<br>的方法，这个方法在节点包含一或多个子节点的情况下返回true；比查询length更简单。</p>
<p>如果传入到appendChild()中的节点已经是文档的一部分了，那结果就是将该节点从原来的位置<br>转移到新位置。</p>
<p>下面要介绍的replaceChild()方法接受的两个参数是：要插入的节点和要替换的节点。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//替换第一个子节点</span></span><br><span class="line"><span class="keyword">var</span> returnedNode = someNode.replaceChild(newNode, someNode.firstChild);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//移除第一个子节点</span></span><br><span class="line"><span class="keyword">var</span> formerFirstChild = someNode.removeChild(someNode.firstChild);</span><br></pre></td></tr></table></figure>
<p>与使用replaceChild()方法一样，通过removeChild()移除的节点仍然为文档所有，只不过在<br>文档中已经没有了自己的位置。</p>
<p>要使用这几个方法必须先取得父节<br>点（使用parentNode 属性）。另外，并不是所有类型的节点都有子节点，如果在不支持子节点的节点<br>上调用了这些方法，将会导致错误发生。</p>
<p>cloneNode()方法接受一个布尔值参数，表示是否执行深复制。在参数为true<br>的情况下，执行深复制，也就是复制节点及其整个子节点树。cloneNode()方法不会复制添加到DOM 节点中的JavaScript 属性，例如事件处<br>理程序等。IE 在此存在一个bug，即它会复制事件处理程序，所以我们建议在复制<br>之前最好先移除事件处理程序。</p>
<p>normalize()，这个方法唯一的作用就是处理文档树中的文本节点。自动删除空的文本节点或合并两个相邻的文本节点。</p>
<ul>
<li>Document类型</li>
</ul>
<p>在Firefox、Safari、Chrome 和Opera 中，可以通过脚本访问Document 类型的构<br>造函数和原型。但在所有浏览器中都可以访问HTMLDocument 类型的构造函数和原型，<br>包括IE8 及后续版本。</p>
<p>虽然DOM 标准规定Document 节点的子节点可以是DocumentType、Element、ProcessingInstruction<br>或Comment，但还可通过以下方式访问其子节点：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> html = <span class="built_in">document</span>.documentElement; <span class="comment">//取得对&lt;html&gt;的引用</span></span><br><span class="line">alert(html === <span class="built_in">document</span>.childNodes[<span class="number">0</span>]); <span class="comment">//true</span></span><br><span class="line">alert(html === <span class="built_in">document</span>.firstChild); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p>作为HTMLDocument 的实例，document 对象还有一个body 属性，直接指向<body>元素。Document 另一个可能的子节点是DocumentType。通常将&lt;!DOCTYPE&gt;标签看成一个与文档其他<br>部分不同的实体。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> doctype = <span class="built_in">document</span>.doctype; <span class="comment">//取得对&lt;!DOCTYPE&gt;的引用</span></span><br></pre></td></tr></table></figure></body></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取得文档标题</span></span><br><span class="line"><span class="keyword">var</span> originalTitle = <span class="built_in">document</span>.title;</span><br><span class="line"><span class="comment">//设置文档标题</span></span><br><span class="line"><span class="built_in">document</span>.title = <span class="string">"New page title"</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取得完整的URL</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">document</span>.URL;</span><br><span class="line"><span class="comment">//取得域名</span></span><br><span class="line"><span class="keyword">var</span> domain = <span class="built_in">document</span>.domain;</span><br><span class="line"><span class="comment">//取得来源页面的URL</span></span><br><span class="line"><span class="keyword">var</span> referrer = <span class="built_in">document</span>.referrer;</span><br></pre></td></tr></table></figure>
<p>在这3 个属性中，只有domain 是可以设置的。，例如p2p.wrox.com，那么就只能将domain 设置为”wrox.com”<br>（URL 中包含”www”，如www.wrox.com 时，也是如此）。<br>当页面中包含来自其他子域的框架或内嵌框架时，通过将每个页面的<br>document.domain 设置为相同的值，这些页面就可以互相访问对方包含的JavaScript 对象了。<br>浏览器对domain 属性还有一个限制，即如果域名一开始是“松散的”（loose），那么不能将它再设<br>置为“紧绷的”（tight）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//假设页面来自于p2p.wrox.com 域</span></span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">"wrox.com"</span>; <span class="comment">//松散的（成功）</span></span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">"p2p.wrox.com"</span>; <span class="comment">//紧绷的（出错！）</span></span><br></pre></td></tr></table></figure>
<p>getElementsByTagName()这个方法会返回一<br>个HTMLCollection 对象，作为一个“动态”集合，该对象与NodeList 非常类似。HTMLCollection 对象还有一个方法，叫做namedItem()，使用这个方法可以通过元素的name<br>特性取得集合中的项。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;img src=<span class="string">"myimage.gif"</span> name=<span class="string">"myImage"</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下两个效果一样</span></span><br><span class="line"><span class="keyword">var</span> myImage = images.namedItem(<span class="string">"myImage"</span>);  <span class="comment">//只会取得第一项</span></span><br><span class="line"><span class="keyword">var</span> myImage = images[<span class="string">"myImage"</span>];</span><br></pre></td></tr></table></figure></p>
<p>第三个方法，也是只有HTMLDocument 类型才有的方法，是getElementsByName()。</p>
<p>由于DOM 分为多个级别，也包含多个部分，因此检测浏览器实现了DOM的哪些部分就十分必要<br>了。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hasXmlDom = <span class="built_in">document</span>.implementation.hasFeature(<span class="string">"XML"</span>, <span class="string">"1.0"</span>);</span><br></pre></td></tr></table></figure></p>
<p>，要想让hasFearture()方法针对所有值都返回true 很容易，但返回true<br>有时候也不意味着实现与规范一致。</p>
<ul>
<li>Element类型</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (element.tagName == <span class="string">"div"</span>) &#123; <span class="comment">//不能这样比较，很容易出错！</span></span><br><span class="line">	<span class="comment">//在此执行某些操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (element.tagName.toLowerCase() == <span class="string">"div"</span>) &#123; <span class="comment">//这样最好（适用于任何文档）</span></span><br><span class="line">	<span class="comment">//在此执行某些操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据HTML5 规范，自定义特性应该加上data-前缀以便验证。开发人员经常不使用getAttribute()，<br>而是只使用对象的属性。只有在取得自定义特性值的情况下，才会使用getAttribute()方法。</p>
<p>不过，像下面这样为DOM元素添加一个自定义的属性，该属性不会自动成为元素的特性。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">div.id = <span class="string">"someOtherId"</span>;</span><br><span class="line">div.align = <span class="string">"left"</span>;</span><br></pre></td></tr></table></figure></p>
<p>不过，像下面这样为DOM元素添加一个自定义的属性，该属性不会自动成为元素的特性。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">div.mycolor = <span class="string">"red"</span>;</span><br><span class="line">alert(div.getAttribute(<span class="string">"mycolor"</span>)); <span class="comment">//null（IE 除外）</span></span><br></pre></td></tr></table></figure></p>
<p>Element 类型是使用attributes 属性的唯一一个DOM 节点类型。attributes 属性中包含一个<br>NamedNodeMap，与NodeList 类似，也是一个“动态”的集合。attributes 属性中包含一系列节点，每个节点的nodeName 就是特性的名称，而节点的nodeValue<br>就是特性的值。要取得元素的id 特性，可以使用以下代码。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> id = element.attributes.getNamedItem(<span class="string">"id"</span>).nodeValue;</span><br><span class="line"><span class="keyword">var</span> id = element.attributes[<span class="string">"id"</span>].nodeValue;   <span class="comment">//同上，简写</span></span><br></pre></td></tr></table></figure></p>
<p>一般来说，由于前面介绍的attributes 的方法不够方便，因此开发人员更多的会使用<br>getAttribute()、removeAttribute()和setAttribute()方法。</p>
<p>创建元素<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">div.id = <span class="string">"myNewDiv"</span>;</span><br><span class="line">div.className = <span class="string">"box"</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(div);</span><br></pre></td></tr></table></figure></p>
<p>在IE 中可以以另一种方式使用createElement()<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">"&lt;div id=\"myNewDiv\" class=\"box\"&gt;&lt;/div &gt;"</span>);</span><br></pre></td></tr></table></figure></p>
<p>在IE7及之前的版本中，会有一些问题，比如不能设置动态创建的<code>&lt;iframe&gt;</code>元素的name 特性。可以通过在createElement()中指定完整的HTML标签来解决。</p>
<p>元素的子节点：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"myList"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span> &gt;</span></span><br></pre></td></tr></table></figure></p>
<p>如果是IE 来解析这些代码，那么<ul>元素会有3 个子节点，分别是3 个<li>元素。但如果是在其<br>他浏览器中，<ul>元素都会有7 个元素，包括3 个<li>元素和4 个文本节点（表示</li><li>元素之间的空<br>白符）。以下在各浏览器会返回相同的子节点数目：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"myList"</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></p>
<p>如果需要通过childNodes 属性执行某些操作，应先检查节点类型：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = element.childNodes.length; i &lt; len; i++) &#123;</span><br><span class="line">	<span class="keyword">if</span> (element.childNodes[i].nodeType == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">//执行某些操作</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>Text类型</li>
</ul>
<p>文本节点还有一个length 属性，保存着节点中字符的数目。而且，<br>nodeValue.length 和data.length 中也保存着同样的值。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">element.className = <span class="string">"message"</span>;</span><br><span class="line"><span class="comment">//创建文本节点</span></span><br><span class="line"><span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="string">"Hello world!"</span>);</span><br><span class="line">element.appendChild(textNode);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(element);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将element下的几个文本节点合并成一个或删除空的文本节点</span></span><br><span class="line">element.normalize();</span><br><span class="line"><span class="comment">//分割文本节点，返回从下标为5的字符开始至结束</span></span><br><span class="line"><span class="keyword">var</span> newNode = element.firstChild.splitText(<span class="number">5</span>);</span><br></pre></td></tr></table></figure></p>
<ul>
<li>Comment类型</li>
</ul>
<p>注释节点，和Text基本相同，只是不能分割。</p>
<ul>
<li>CDATASection类型</li>
</ul>
<p>CDATASection 类型只针对基于XML 的文档，表示的是CDATA 区域。与Comment 类似，<br>CDATASection 类型继承自Text 类型，因此拥有除splitText()之外的所有字符串操作方法。</p>
<ul>
<li>DocumentType类型</li>
</ul>
<p>DocumentType 类型在Web 浏览器中并不常用，仅有Firefox、Safari 和Opera 支持它。DocumentType 的name 属性中保存的就是”HTML”：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert(<span class="built_in">document</span>.doctype.name); <span class="comment">//"HTML"</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>DocumentFragment类型</li>
</ul>
<p>可以像下面这样使用一个文档片段来保存创建的列表项，在ul中插入3个li：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">"myList"</span>);</span><br><span class="line"><span class="keyword">var</span> li = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">	li = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span><br><span class="line">	li.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"Item "</span> + (i + <span class="number">1</span>)));</span><br><span class="line">	fragment.appendChild(li);</span><br><span class="line">&#125;</span><br><span class="line">ul.appendChild(fragment);</span><br></pre></td></tr></table></figure></p>
<ul>
<li>Attr类型</li>
</ul>
<p>元素的特性在DOM 中以Attr 类型来表示。在所有浏览器中（包括IE8），都可以访问Attr 类型<br>的构造函数和原型。</p>
<h5 id="【10-2-DOM操作技术】"><a href="#【10-2-DOM操作技术】" class="headerlink" title="【10.2 DOM操作技术】"></a>【10.2 DOM操作技术】</h5><ul>
<li>动态脚本</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">script.type = <span class="string">"text/javascript"</span>;</span><br><span class="line"><span class="keyword">var</span> code = <span class="string">"function sayHi()&#123;alert('hi');&#125;"</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	script.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"code"</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">	script.text = <span class="string">"code"</span>;  <span class="comment">//兼容IE，</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script);</span><br></pre></td></tr></table></figure>
<p>实际上，这样执行代码与在全局作用域中把相同的字符串传递给eval()是一样的。</p>
<ul>
<li>动态样式</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;link rel="stylesheet" type="text/css" href="styles.css"&gt;</span></span><br><span class="line"><span class="keyword">var</span> link = <span class="built_in">document</span>.createElement(<span class="string">"link"</span>);</span><br><span class="line">link.rel = <span class="string">"stylesheet"</span>;</span><br><span class="line">link.type = <span class="string">"text/css"</span>;</span><br><span class="line">link.href = <span class="string">"style.css"</span>;</span><br><span class="line"><span class="keyword">var</span> head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>];  <span class="comment">//加到head而不是body</span></span><br><span class="line">head.appendChild(link);</span><br></pre></td></tr></table></figure>
<p>在IE 中则会报错。IE 将<code>&lt;style&gt;</code>视为一个特殊的、与<code>&lt;script&gt;</code>类似的节点，不允许访问其子节点。解决IE中这个问题的办法，就是访问元素的styleSheet属性，该属性又有一个cssText 属性，可以接受CSS 代码。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> style = <span class="built_in">document</span>.createElement(<span class="string">"style"</span>);</span><br><span class="line">style.type = <span class="string">"text/css"</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	style.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"body&#123;background-color:red&#125;"</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">	style.styleSheet.cssText = <span class="string">"body&#123;background-color:red&#125;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>];</span><br><span class="line">head.appendChild(style);</span><br></pre></td></tr></table></figure></p>
<ul>
<li>操作表格</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建table</span></span><br><span class="line"><span class="keyword">var</span> table = <span class="built_in">document</span>.createElement(<span class="string">"table"</span>);</span><br><span class="line">table.border = <span class="number">1</span>;</span><br><span class="line">table.width = <span class="string">"100%"</span>;</span><br><span class="line"><span class="comment">//创建tbody</span></span><br><span class="line"><span class="keyword">var</span> tbody = <span class="built_in">document</span>.createElement(<span class="string">"tbody"</span>);</span><br><span class="line">table.appendChild(tbody);</span><br><span class="line"><span class="comment">//创建第一行</span></span><br><span class="line">tbody.insertRow(<span class="number">0</span>);</span><br><span class="line">tbody.rows[<span class="number">0</span>].insertCell(<span class="number">0</span>);</span><br><span class="line">tbody.rows[<span class="number">0</span>].cells[<span class="number">0</span>].appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"Cell 1,1"</span>));</span><br><span class="line">tbody.rows[<span class="number">0</span>].insertCell(<span class="number">1</span>);</span><br><span class="line">tbody.rows[<span class="number">0</span>].cells[<span class="number">1</span>].appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"Cell 2,1"</span>));</span><br><span class="line"><span class="comment">//创建第二行</span></span><br><span class="line">tbody.insertRow(<span class="number">1</span>);</span><br><span class="line">tbody.rows[<span class="number">1</span>].insertCell(<span class="number">0</span>);</span><br><span class="line">tbody.rows[<span class="number">1</span>].cells[<span class="number">0</span>].appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"Cell 1,2"</span>));</span><br><span class="line">tbody.rows[<span class="number">1</span>].insertCell(<span class="number">1</span>);</span><br><span class="line">tbody.rows[<span class="number">1</span>].cells[<span class="number">1</span>].appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"Cell 2,2"</span>));</span><br><span class="line"><span class="comment">//将表格添加到文档主体中</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(table);</span><br></pre></td></tr></table></figure>
<ul>
<li>使用Nodelist</li>
</ul>
<p>理解NodeList 及其“近亲”NamedNodeMap 和HTMLCollection，是从整体上透彻理解DOM的<br>关键所在。这三个集合都是“动态的”。以下代码将无限循环：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> divs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"div"</span>),</span><br><span class="line">	i,</span><br><span class="line">	div;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; divs.length; i++) &#123;</span><br><span class="line">	div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">	<span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="十一、DOM扩展"><a href="#十一、DOM扩展" class="headerlink" title="十一、DOM扩展"></a>十一、DOM扩展</h4><hr>
<h5 id="【11-1-选择符API】"><a href="#【11-1-选择符API】" class="headerlink" title="【11.1 选择符API】"></a>【11.1 选择符API】</h5><p>Selectors API Level 1 的核心是两个方法：querySelector()和querySelectorAll()。在兼容的浏<br>览器中，可以通过Document 及Element 类型的实例调用它们。目前已完全支持Selectors API Level 1<br>的浏览器有IE 8+、Firefox 3.5+、Safari 3.1+、Chrome 和Opera 10+。</p>
<ul>
<li>querySelector()方法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取得body 元素</span></span><br><span class="line"><span class="keyword">var</span> body = <span class="built_in">document</span>.querySelector(<span class="string">"body"</span>);</span><br><span class="line"><span class="comment">//取得ID 为"myDiv"的元素</span></span><br><span class="line"><span class="keyword">var</span> myDiv = <span class="built_in">document</span>.querySelector(<span class="string">"#myDiv"</span>);</span><br><span class="line"><span class="comment">//取得类为"selected"的第一个元素</span></span><br><span class="line"><span class="keyword">var</span> selected = <span class="built_in">document</span>.querySelector(<span class="string">".selected"</span>);</span><br><span class="line"><span class="comment">//取得类为"button"的第一个图像元素</span></span><br><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.body.querySelector(<span class="string">"img.button"</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>querySelectorAll()方法</li>
</ul>
<p>只要传给querySelectorAll()方法的CSS 选择符有效，该方法都会返回一个NodeList 对象，<br>而不管找到多少匹配的元素。如果没有找到匹配的元素，NodeList 就是空的。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取得某&lt;div&gt;中的所有&lt;em&gt;元素（类似于getElementsByTagName("em")）</span></span><br><span class="line"><span class="keyword">var</span> ems = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>).querySelectorAll(<span class="string">"em"</span>);</span><br><span class="line"><span class="comment">//取得类为"selected"的所有元素</span></span><br><span class="line"><span class="keyword">var</span> selecteds = <span class="built_in">document</span>.querySelectorAll(<span class="string">".selected"</span>);</span><br><span class="line"><span class="comment">//取得所有&lt;p&gt;元素中的所有&lt;strong&gt;元素</span></span><br><span class="line"><span class="keyword">var</span> strongs = <span class="built_in">document</span>.querySelectorAll(<span class="string">"p strong"</span>);</span><br></pre></td></tr></table></figure></p>
<p>要取得返回的NodeList 中的每一个元素，可以使用item()方法，也可以使用方括号语法，比如：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i, len, strong;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>, len = strongs.length; i &lt; len; i++) &#123;</span><br><span class="line">	strong = strongs[i]; <span class="comment">//或者strongs.item(i)</span></span><br><span class="line">	strong.className = <span class="string">"important"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>matchesSelector()方法(不兼容IE8及以下)</li>
</ul>
<p>Selectors API Level 2 规范为Element 类型新增了一个方法matchesSelector()。这个方法接收<br>一个参数，即CSS 选择符，如果调用元素与该选择符匹配，返回true；否则，返回false。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.body.matchesSelector(<span class="string">"body.page1"</span>))&#123;</span><br><span class="line"><span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在取得某个元素引用的情况下，使用这个方法能够方便地检测它是否会被querySelector()或<br>querySelectorAll()方法返回。</p>
<h5 id="【元素遍历】"><a href="#【元素遍历】" class="headerlink" title="【元素遍历】"></a>【元素遍历】</h5><p>IE9 及之前版本不会返回文本节点，而其他所有浏览器都会返回文本节点，为兼容加入以下新属性（不兼容IE8及以下）</p>
<p> childElementCount：返回子元素（不包括文本节点和注释）的个数。</p>
<p> firstElementChild：指向第一个子元素；firstChild 的元素版。</p>
<p> lastElementChild：指向最后一个子元素；lastChild 的元素版。</p>
<p> previousElementSibling：指向前一个同辈元素；previousSibling 的元素版。</p>
<p> nextElementSibling：指向后一个同辈元素；nextSibling 的元素版。</p>
<p>下面来看一个例子。过去，要跨浏览器遍历某元素的所有子元素，需要像下面这样写代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i,</span><br><span class="line">	len,</span><br><span class="line">	child = element.firstChild;</span><br><span class="line"><span class="keyword">while</span> (child != element.lastChild) &#123;</span><br><span class="line">	<span class="keyword">if</span> (child.nodeType == <span class="number">1</span>) &#123; <span class="comment">//检查是不是元素</span></span><br><span class="line">		processChild(child);</span><br><span class="line">	&#125;</span><br><span class="line">	child = child.nextSibling;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而使用Element Traversal 新增的元素，代码会更简洁。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i,</span><br><span class="line">	len,</span><br><span class="line">	child = element.firstElementChild;</span><br><span class="line"><span class="keyword">while</span> (child != element.lastElementChild) &#123;</span><br><span class="line">	processChild(child); <span class="comment">//已知其是元素</span></span><br><span class="line">	child = child.nextElementSibling;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="【11-3-HTML5】跳过"><a href="#【11-3-HTML5】跳过" class="headerlink" title="【11.3 HTML5】跳过"></a>【11.3 HTML5】跳过</h5><ul>
<li>与类相关</li>
</ul>
<p>getElementsByClassName()方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取得所有类中包含"username"和"current"的元素，类名的先后顺序无所谓</span></span><br><span class="line"><span class="keyword">var</span> allCurrentUsernames = <span class="built_in">document</span>.getElementsByClassName(<span class="string">"username current"</span>);</span><br><span class="line"><span class="comment">//取得ID 为"myDiv"的元素中带有类名"selected"的所有元素</span></span><br><span class="line"><span class="keyword">var</span> selected = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>).getElementsByClassName(<span class="string">"selected"</span>);</span><br></pre></td></tr></table></figure>
<p><em>删除”user”类</em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//首先，取得类名字符串并拆分成数组</span></span><br><span class="line"><span class="keyword">var</span> classNames = div.className.split(<span class="regexp">/\s+/</span>);</span><br><span class="line"><span class="comment">//找到要删的类名</span></span><br><span class="line"><span class="keyword">var</span> pos = <span class="number">-1</span>,</span><br><span class="line">	i,</span><br><span class="line">	len;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>, len = classNames.length; i &lt; len; i++) &#123;</span><br><span class="line">	<span class="keyword">if</span> (classNames[i] == <span class="string">"user"</span>) &#123;</span><br><span class="line">		pos = i;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除类名</span></span><br><span class="line">classNames.splice(i, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//把剩下的类名拼成字符串并重新设置</span></span><br><span class="line">div.className = classNames.join(<span class="string">" "</span>);</span><br></pre></td></tr></table></figure>
<p><em>classList 属性</em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除"disabled"类</span></span><br><span class="line">div.classList.remove(<span class="string">"disabled"</span>);</span><br><span class="line"><span class="comment">//添加"current"类</span></span><br><span class="line">div.classList.add(<span class="string">"current"</span>);</span><br><span class="line"><span class="comment">//切换"user"类</span></span><br><span class="line">div.classList.toggle(<span class="string">"user"</span>);</span><br><span class="line"><span class="comment">//确定元素中是否包含既定的类名</span></span><br><span class="line"><span class="keyword">if</span> (div.classList.contains(<span class="string">"bd"</span>) &amp;&amp; !div.classList.contains(<span class="string">"disabled"</span>)) &#123;</span><br><span class="line">	<span class="comment">//执行操作</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//迭代类名</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = div.classList.length; i &lt; len; i++) &#123;</span><br><span class="line">	doSomething(div.classList[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>焦点管理</li>
</ul>
<p>document.activeElement 属性始终会引用DOM 中当前获得了焦点的元素。默认情况下，文档刚刚加载完成时，document.activeElement 中保存的是document.body 元<br>素的引用。文档加载期间，document.activeElement 的值为null。document.hasFocus()方法用于确定文档是否获得了焦点。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">button.focus();</span><br><span class="line">alert(<span class="built_in">document</span>.hasFocus()); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>HTMLDocument的变化</li>
</ul>
<p>Document 的readyState 属性有两个可能的值：<br> loading，正在加载文档；<br> complete，已经加载完文档。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.readyState == <span class="string">"complete"</span>) &#123;</span><br><span class="line">	<span class="comment">//执行操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所有主流浏览器都支持document.readyState</p>
<p><em>IE 兼容模式</em></p>
<p>在标准模式下，document.compatMode 的<br>值等于”CSS1Compat”，而在混杂模式下，document.compatMode 的值等于”BackCompat”。支持所有主流浏览器。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.compatMode == <span class="string">"CSS1Compat"</span>) &#123;</span><br><span class="line">	alert(<span class="string">"Standards mode"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	alert(<span class="string">"Quirks mode"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//documet.head为HTML5新增，仅支持chrome和safari，以下为兼容式</span></span><br><span class="line"><span class="keyword">var</span> head = <span class="built_in">document</span>.head || <span class="built_in">document</span>.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li>字符集属性</li>
</ul>
<p>charset 属性表示文档中实际使用的字符集，也可以用来指定新字符集。默认情况下，这个属性的值为”UTF-16”，但可以通过<code>&lt;meta&gt;</code>元素、响应头部或直接设置charset 属性修改这个值。支持主流浏览器<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert(<span class="built_in">document</span>.charset); <span class="comment">//"UTF-16"</span></span><br><span class="line"><span class="built_in">document</span>.charset = <span class="string">"UTF-8"</span>;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>自定义数据属性</li>
</ul>
<p>HTML5 规定可以为元素添加非标准的属性，但要添加前缀data-,可以通过元素的dataset 属性来访问自定义属性的值,仅有firefox和chrome支持<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">"myDiv"</span> data-appId=<span class="string">"12345"</span> data-myname=<span class="string">"Nicholas"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</span><br><span class="line"><span class="comment">//取得自定义属性的值</span></span><br><span class="line"><span class="keyword">var</span> appId = div.dataset.appId;</span><br><span class="line"><span class="keyword">var</span> myName = div.dataset.myname;</span><br><span class="line"><span class="comment">//设置值</span></span><br><span class="line">div.dataset.appId = <span class="number">23456</span>;</span><br><span class="line">div.dataset.myname = <span class="string">"Michael"</span>;</span><br><span class="line"><span class="comment">//有没有"myname"值呢？</span></span><br><span class="line"><span class="keyword">if</span> (div.dataset.myname) &#123;</span><br><span class="line">	alert(<span class="string">"Hello, "</span> + div.dataset.myname);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>插入标记</li>
</ul>
<p>比如，在大多数浏览器中，通过innerHTML 插入<code>&lt;script&gt;</code>元素并不会执行其中的脚本。IE8及更早版本是唯一能在这种情况下执行脚本的浏览器，但必须满足一些条件。一是必须为<code>&lt;script&gt;</code>元素指定defer 属性，二是<code>&lt;script&gt;</code>元素必须位于（微软所谓的）“有作用域的元素”（scoped element）之后。<code>&lt;script&gt;</code>元素被认为是“无作用域的元素”（NoScope element），也就是在页面中看不到的元素，与<code>&lt;style&gt;</code>元素或注释类似。如果通过innerHTML 插入的字符串开头就是一个“无作用域的元素”，那么IE会在解析这个字符串前先删除该元素。换句话说，以下代码达不<br>到目的：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">div.innerHTML = <span class="string">"&lt;script defer&gt;alert('hi');&lt;\/script&gt;"</span>; <span class="comment">//无效</span></span><br></pre></td></tr></table></figure></p>
<p>此时，innerHTML 字符串一开始（而且整个）就是一个“无作用域的元素”，所以这个字符串会变成空字符串。如果想插入这段脚本，必须在前面添加一个“有作用域的元素”，可以是一个文本节点，也可以是一个没有结束标签的元素如<input>。例如,下面这几行代码都可以正常执行：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">div.innerHTML = <span class="string">"_&lt;script defer&gt;alert('hi');&lt;\/script&gt;"</span>;</span><br><span class="line">div.innerHTML = <span class="string">"&lt;div&gt;&amp;nbsp;&lt;/div&gt;&lt;script defer&gt;alert('hi');&lt;\/script&gt;"</span>;</span><br><span class="line">div.innerHTML = <span class="string">"&lt;input type=\"hidden\"&gt;&lt;script defer&gt;alert('hi');&lt;\/script&gt;"</span>;  <span class="comment">//首选，不影响布局</span></span><br></pre></td></tr></table></figure></p>
<p>并不是所有元素都支持innerHTML 属性。不支持innerHTML 的元素有：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;col&gt;、&lt;colgroup&gt;、</span><br><span class="line">&lt;frameset&gt;、&lt;head&gt;、&lt;html&gt;、&lt;style&gt;、&lt;table&gt;、&lt;tbody&gt;、&lt;thead&gt;、&lt;tfoot&gt;和&lt;tr&gt;</span><br></pre></td></tr></table></figure></p>
<p>此外，在IE8 及更早版本中，<code>&lt;title&gt;</code>元素也没有innerHTML 属性。</p>
<p>IE8 为此提供了window.toStaticHTML()方法，这个方法接收一个参数，即一个HTML字符串；返回一个经过无害处理后的版本——从源HTML 中删除所有脚本节点和事件处理程序属性。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"&lt;a href=\"#\" onclick=\"alert('hi')\"&gt;Click Me&lt;/a&gt;"</span>;</span><br><span class="line"><span class="keyword">var</span> sanitized = <span class="built_in">window</span>.toStaticHTML(text); <span class="comment">//Internet Explorer 8 only</span></span><br><span class="line">alert(sanitized); <span class="comment">//"&lt;a href=\"#\"&gt;Click Me&lt;/a&gt;"</span></span><br></pre></td></tr></table></figure></p>
<p>这个例子将一个HTML 链接字符串传给了toStaticHTML()方法，得到的无害版本中去掉了onclick属性。虽然目前只有IE8 原生支持这个方法，但我们还是建议读者在通过innerHTML插入代码之前，尽可能先手工检查一下其中的文本内容。</p>
<p><em>outerHTML 属性</em></p>
<p>在读模式下，outerHTML 返回调用它的元素及所有子节点的HTML标签。在写模式下，outerHTML会根据指定的HTML字符串创建新的DOM子树，然后用这个DOM子树完全替换调用元素。</p>
<p><em>insertAdjacentHTML()方法</em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//作为前一个同辈元素插入</span></span><br><span class="line">element.insertAdjacentHTML(<span class="string">"beforebegin"</span>, <span class="string">"&lt;p&gt;Hello world!&lt;/p&gt;"</span>);</span><br><span class="line"><span class="comment">//作为第一个子元素插入</span></span><br><span class="line">element.insertAdjacentHTML(<span class="string">"afterbegin"</span>, <span class="string">"&lt;p&gt;Hello world!&lt;/p&gt;"</span>);</span><br><span class="line"><span class="comment">//作为最后一个子元素插入</span></span><br><span class="line">element.insertAdjacentHTML(<span class="string">"beforeend"</span>, <span class="string">"&lt;p&gt;Hello world!&lt;/p&gt;"</span>);</span><br><span class="line"><span class="comment">//作为后一个同辈元素插入</span></span><br><span class="line">element.insertAdjacentHTML(<span class="string">"afterend"</span>, <span class="string">"&lt;p&gt;Hello world!&lt;/p&gt;"</span>);</span><br></pre></td></tr></table></figure>
<p>支持insertAdjacentHTML()方法的浏览器有IE、Firefox 8+、Safari、Opera 和Chrome。</p>
<p><em>内存与性能问题</em></p>
<p>在使用innerHTML、outerHTML 属性和insertAdjacentHTML()方法时，最好先手工删除要被替换的元素的所有事件处理程序和JavaScript 对象属性。</p>
<h5 id="【专有扩展】"><a href="#【专有扩展】" class="headerlink" title="【专有扩展】"></a>【专有扩展】</h5><ul>
<li>文档模式</li>
</ul>
<p>IE8 引入了一个新的概念叫“文档模式”（document mode）。页面的文档模式决定了可以使用什么功能。换句话说，文档模式决定了你可以使用哪个级别的CSS，可以在JavaScript中使用哪些API，以及如何对待文档类型（doctype）。到了IE9，总共有4种文档模式：IE5,IE7,IE8,IE9</p>
<p>要强制浏览器以某种模式渲染页面，可以使用HTTP 头部信息X-UA-Compatible，或通过等价的<br><code>&lt;meta&gt;</code>标签来设置：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;meta http-equiv=<span class="string">"X-UA-Compatible"</span> content=<span class="string">"IE=IEVersion"</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//IE7模式</span></span><br><span class="line">&lt;meta http-equiv=<span class="string">"X-UA-Compatible"</span> content=<span class="string">"IE=EmulateIE7"</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不考虑文档类型声明，直接使用IE7 标准模式</span></span><br><span class="line">&lt;meta http-equiv=<span class="string">"X-UA-Compatible"</span> content=<span class="string">"IE=7"</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>注意，这里IE 的版本（IEVersion）有以下一些不同的值，而且这些值并不一定与上述4 种文档<br>模式对应。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> Edge：始终以最新的文档模式来渲染页面。忽略文档类型声明。对于IE8，始终保持以IE8 标准模式渲染页面。对于IE9，则以IE9 标准模式渲染页面。</span><br><span class="line"> EmulateIE9：如果有文档类型声明，则以IE9 标准模式渲染页面，否则将文档模式设置为IE5。</span><br><span class="line"> EmulateIE8：如果有文档类型声明，则以IE8 标准模式渲染页面，否则将文档模式设置为IE5。</span><br><span class="line"> EmulateIE7：如果有文档类型声明，则以IE7 标准模式渲染页面，否则将文档模式设置为IE5。</span><br><span class="line"> <span class="number">9</span>：强制以IE9 标准模式渲染页面，忽略文档类型声明。</span><br><span class="line"> <span class="number">8</span>：强制以IE8 标准模式渲染页面，忽略文档类型声明。</span><br><span class="line"> <span class="number">7</span>：强制以IE7 标准模式渲染页面，忽略文档类型声明。</span><br><span class="line"> <span class="number">5</span>：强制将文档模式设置为IE5，忽略文档类型声明。</span><br></pre></td></tr></table></figure>
<p>没有规定说必须在页面中设置X-UA-Compatible。默认情况下，浏览器会通过文档类型声明来确定是使用最佳的可用文档模式，还是使用混杂模式。</p>
<ul>
<li>children属性</li>
</ul>
<p>只取得元素节点，而childNodes在某些浏览器中会同时取得文本节点</p>
<ul>
<li>contains()方法</li>
</ul>
<p>如果被检测的节点是后代节点，该方法返回true。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert(<span class="built_in">document</span>.documentElement.contains(<span class="built_in">document</span>.body)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>插入文本</li>
</ul>
<p>通过innertText 属性可以操作元素中包含的所有文本内容，包括子文档树中的文本。在通过innerText读取值时，它会按照由浅入深的顺序，将子文档树中的所有文本拼接起来。在通过innerText 写入值时，结果会删除元素的所有子节点，插入包含相应文本值的文本节点。由于不同浏览器处理空白符的方式不同，因此输出的文本可能会也可能不会包含原始HTML 代码中的缩进。此外，设置innerText属性的同时，也对文本中存在的HTML语法字符（小于号、大于号、引号及和号）进行了编码。利用这一点，可以通过innerText 属性过滤掉HTML 标签。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">div.innerText = div.innerText;</span><br></pre></td></tr></table></figure></p>
<p>支持innerText 属性的浏览器包括IE4+、Safari 3+、Opera 8+和Chrome。Firefox 虽然不支持<br>innerText，但支持作用类似的textContent 属性。兼容的做法：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInnerText</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">typeof</span> element.textContent == <span class="string">"string"</span>) ?</span><br><span class="line">		element.textContent : element.innerText;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setInnerText</span>(<span class="params">element, text</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> element.textContent == <span class="string">"string"</span>) &#123;</span><br><span class="line">		element.textContent = text;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		element.innerText = text;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>outerText 属性</em></p>
<p>在读取文本值时，outerText 与innerText 的结果完全一样。但在写模式下，outerText 就完全不同了：outerText不只是替换调用它的元素的子节点，而是会替换整个元素（包括子节点）。支持outerText属性的浏览器有IE4+、Safari 3+、Opera 8+和Chrome。由于这个属性会导致调用它的元素不存在，因此并不常用。</p>
<h4 id="十二、DOM2和DOM3"><a href="#十二、DOM2和DOM3" class="headerlink" title="十二、DOM2和DOM3"></a>十二、DOM2和DOM3</h4><hr>
<h5 id="【12-1-DOM变化】"><a href="#【12-1-DOM变化】" class="headerlink" title="【12.1 DOM变化】"></a>【12.1 DOM变化】</h5><ul>
<li><p>针对XML命名空间的变化（跳过）</p>
</li>
<li><p>其他方面的变化 </p>
</li>
</ul>
<p>DocumentType 类型新增了3 个属性：publicId、systemId 和internalSubset。<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"</span><br><span class="line">"http://www.w3.org/TR/html4/strict.dtd"&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>对这个文档类型声明而言，publicId 是<code>&quot;-//W3C//DTD HTML 4.01//EN&quot;</code>，而systemId 是<code>&quot;http:
//www.w3.org/TR/html4/strict.dtd&quot;</code>。</p>
<p>最后一个属性internalSubset，用于访问包含在文档类型声明中的额外定义<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"</span><br><span class="line">"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"</span><br><span class="line">[&lt;!ELEMENT name (#PCDATA)&gt;] &gt;</span></span><br></pre></td></tr></table></figure></p>
<p>访问document.doctype.internalSubset 将得到”&lt;!ELEMENT name (#PCDATA)&gt;”。这种内部<br>子集（internal subset）在HTML 中极少用到，在XML 中可能会更常见一些。</p>
<ul>
<li>Document 类型的变化</li>
</ul>
<p>importNode()方法与Element 的cloneNode()方法非常相似，它接受两个参数：要复制的节点和一个表示是否复制子节点的布尔值。这个方法在HTML 文档中并不常用，在XML 文档中用得比较多<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> newNode = <span class="built_in">document</span>.importNode(oldNode, <span class="literal">true</span>); <span class="comment">//导入节点及其所有子节点</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(newNode);</span><br></pre></td></tr></table></figure></p>
<p>defaultView 的属性，其中保存着一个指针，指向拥有给定文档的窗口（或框架）。除IE之外的所有浏览器都支持defaultView属性。在IE 中有一个等价的属性名<br>叫parentWindow（Opera 也支持这个属性）。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> parentWindow = <span class="built_in">document</span>.defaultView || <span class="built_in">document</span>.parentWindow;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>框架的变化</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">"myIframe"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//取得框架内容的文档对象</span></span><br><span class="line"><span class="keyword">var</span> iframeDoc = iframe.contentDocument; <span class="comment">//在IE8 以前的版本中无效</span></span><br></pre></td></tr></table></figure>
<p>兼容做法：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">"myIframe"</span>);</span><br><span class="line"><span class="comment">//先取得框架的window对象，所有浏览器都支持contentWindow 属性</span></span><br><span class="line"><span class="keyword">var</span> iframeDoc = iframe.contentDocument || iframe.contentWindow.document;</span><br></pre></td></tr></table></figure></p>
<h5 id="【12-2-样式】"><a href="#【12-2-样式】" class="headerlink" title="【12.2 样式】"></a>【12.2 样式】</h5><p>要确定浏览器是否支持DOM2 级定义的CSS 能力<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> supportsDOM2CSS = <span class="built_in">document</span>.implementation.hasFeature(<span class="string">"CSS"</span>, <span class="string">"2.0"</span>);</span><br><span class="line"><span class="keyword">var</span> supportsDOM2CSS2 = <span class="built_in">document</span>.implementation.hasFeature(<span class="string">"CSS2"</span>, <span class="string">"2.0"</span>);</span><br></pre></td></tr></table></figure></p>
<ul>
<li>访问元素的样式</li>
</ul>
<p>特殊的属性名转换float-&gt;cssFloat,IE是特殊的styleFloat，其他的都采用驼峰法如background-image -&gt;backgroundImage<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置行内style的内容</span></span><br><span class="line">myDiv.style.cssText = <span class="string">"width: 25px; height: 100px; background-color: green"</span>;</span><br><span class="line">myDiv.style.removeProperty(<span class="string">"border"</span>);  <span class="comment">//删除属性</span></span><br></pre></td></tr></table></figure></p>
<p>“DOM2 级样式”增强了document.defaultView，提供了getComputedStyle()方法。这个方法接受两个参数：要取得计算样式的元素和一个伪元素字符串（例如”:after”）。如果不需要伪元素信息，第二个参数可以是null。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> computedStyle = <span class="built_in">document</span>.defaultView.getComputedStyle(myDiv, <span class="literal">null</span>);</span><br><span class="line">alert(computedStyle.backgroundColor); <span class="comment">// "red"</span></span><br><span class="line">alert(computedStyle.border); <span class="comment">// 在某些浏览器中是"1px solid black"</span></span><br></pre></td></tr></table></figure>
<p>IE 不支持getComputedStyle()方法，但它有一种类似的概念。在IE中，每个具有style属性的元素还有一个currentStyle 属性。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> computedStyle = myDiv.currentStyle;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>操作样式表</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sheet = <span class="built_in">document</span>.styleSheets[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> rules = sheet.cssRules || sheet.rules; <span class="comment">//取得规则列表</span></span><br><span class="line"><span class="keyword">var</span> rule = rules[<span class="number">0</span>]; <span class="comment">//取得第一条规则</span></span><br><span class="line">rule.style.backgroundColor = <span class="string">"red"</span></span><br></pre></td></tr></table></figure>
<p>insertRule()方法。这个方法接受两个参数：规则文本和表示在哪里插入规则的索引。IE8及更早版本支持一个类似的方法，名叫addRule()，也接收两必选参数：选择符文本和CSS样式信息；一个可选参数：插入规则的位置。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 兼容函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertRule</span>(<span class="params">sheet, selectorText, cssText, position</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (sheet.insertRule) &#123;</span><br><span class="line">		sheet.insertRule(selectorText + <span class="string">"&#123;"</span> + cssText + <span class="string">"&#125;"</span>, position);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (sheet.addRule) &#123;</span><br><span class="line">		sheet.addRule(selectorText, cssText, position);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">insertRule(<span class="built_in">document</span>.styleSheets[<span class="number">0</span>], <span class="string">"body"</span>, <span class="string">"background-color: silver"</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除规则</span></span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">deleteRule</span>(<span class="params">sheet, index</span>) </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (sheet.deleteRule) &#123;</span><br><span class="line">				sheet.deleteRule(index);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (sheet.removeRule) &#123;</span><br><span class="line">				sheet.removeRule(index);  <span class="comment">//仅对IE有效</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>与添加规则相似，删除规则也不是实际Web开发中常见的做法。考虑到删除规则可能会影响CSS层叠的效果，因此请大家慎重使用。</p>
<ul>
<li>元素大小</li>
</ul>
<p>要想知道某个元素在页面上的偏移量，将这个元素的offsetLeft和offsetTop与其offsetParent的相同属性相加，如此循环直至根元素，就可以得到一个基本准确的值。（对于表格和内嵌框架不完全准确）<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getElementLeft</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> actualLeft = element.offsetLeft;</span><br><span class="line">	<span class="keyword">var</span> current = element.offsetParent;</span><br><span class="line">	<span class="keyword">while</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">		actualLeft += current.offsetLeft;</span><br><span class="line">		current = current.offsetParent;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> actualLeft;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>元素的客户区大小（client dimension），指的是元素内容及其内边距所占据的空间大小。有关客户区<br>大小的属性有两个：clientWidth 和clientHeight。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getViewport</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">document</span>.compatMode == <span class="string">"BackCompat"</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			width: <span class="built_in">document</span>.body.clientWidth,</span><br><span class="line">			height: <span class="built_in">document</span>.body.clientHeight</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			width: <span class="built_in">document</span>.documentElement.clientWidth,</span><br><span class="line">			height: <span class="built_in">document</span>.documentElement.clientHeight</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数首先检查document.compatMode 属性，以确定浏览器是否运行在混杂模式,这个函数会返回一个对象，包含两个属性：width和height；表示浏览器视口（<html>或<body>元素）的大小。</body></html></p>
<p>带有垂直滚动条的页面总高度就是document.documentElement.scrollHeight。在确定文档的总高度时（包括基于视口的最小高度时），必须取得scrollWidth/clientWidth 和<br>scrollHeight/clientHeight 中的最大值:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> docHeight = <span class="built_in">Math</span>.max(<span class="built_in">document</span>.documentElement.scrollHeight,<span class="built_in">document</span>.documentElement.clientHeight);</span><br><span class="line"><span class="keyword">var</span> docWidth = <span class="built_in">Math</span>.max(<span class="built_in">document</span>.documentElement.scrollWidth,<span class="built_in">document</span>.documentElement.clientWidth);</span><br></pre></td></tr></table></figure></p>
<p>注意，对于运行在混杂模式下的IE，则需要用document.body 代替document.document-<br>Element。</p>
<ul>
<li>确定元素大小</li>
</ul>
<p>getBoundingClientRect()方法兼容复杂，参考书本P325</p>
<h5 id="【12-3-遍历、12-3-范围】暂跳过"><a href="#【12-3-遍历、12-3-范围】暂跳过" class="headerlink" title="【12.3 遍历、12.3 范围】暂跳过"></a>【12.3 遍历、12.3 范围】暂跳过</h5><h4 id="十三、事件"><a href="#十三、事件" class="headerlink" title="十三、事件"></a>十三、事件</h4><hr>
<h5 id="【13-1-事件流】"><a href="#【13-1-事件流】" class="headerlink" title="【13.1 事件流】"></a>【13.1 事件流】</h5><ul>
<li>事件冒泡</li>
</ul>
<p>IE 的事件流叫做事件冒泡（event bubbling），即事件开始时由最具体的元素（文档中嵌套层次最深<br>的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。如果你单击了页面中的<div>元素，那么这个click 事件会按照如下顺序传播：<code>&lt;div&gt; &lt;body&gt; &lt;html&gt; document</code><br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>Event Bubbling Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv"</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div></p>
<ul>
<li>事件捕获</li>
</ul>
<p>事件捕获的思想是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。事件捕获的用意在于在事件到达预定目标之前捕获它。在事件捕获过程中，document对象首先接收到click事件，然后事件沿DOM树依次向下，一直传播到事件的实际目标，即<div>元素:<code>document &lt;html&gt; &lt;body&gt; &lt;div&gt;</code></div></p>
<p>由于老版本的浏览器不支持，因此很少有人使用事件捕获。我们也建议读者放心地使用事件冒泡，<br>在有特殊需要时再使用事件捕获。</p>
<ul>
<li>DOM事件流</li>
</ul>
<p>“DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。在DOM事件流中，实际的目标（<code>&lt;div&gt;</code>元素）在捕获阶段不会接收到事件。这意味着在捕获阶段，事件从<code>document</code>到<code>&lt;html&gt;</code>再到<code>&lt;body&gt;</code>后就停止了。下一个阶段是“处于目标”阶段，于是事件在<code>&lt;div&gt;</code>上发生，并在事件处理（后面将会讨论这个概念）中被看成冒泡阶段的一部分。然后，冒泡阶段发生，事件又传播回文档。</p>
<p>即使“DOM2 级事件”规范明确要求捕<br>获阶段不会涉及事件目标，但IE9、Safari、Chrome、Firefox 和Opera 9.5 及更高版本都会在捕获阶段触<br>发事件对象上的事件。结果，就是有两个机会在目标对象上面操作事件。</p>
<h5 id="【13-2-事件处理程序】"><a href="#【13-2-事件处理程序】" class="headerlink" title="【13.2 事件处理程序】"></a>【13.2 事件处理程序】</h5><ul>
<li>HTML事件处理程序</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Click Me"</span> <span class="attr">onclick</span>=<span class="string">"alert('Clicked')"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>。由于这个值是JavaScript，因此不能在其中使用未经转义的HTML 语法字符，<br>例如和号（&amp;）、双引号（””）、小于号（&lt;）或大于号（&gt;）。如果一定要使用双引号则用以下：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Click Me"</span> <span class="attr">onclick</span>=<span class="string">"alert(&amp;quot;Clicked&amp;quot;)"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>如果HTML事件里面的函数还没有加载完成就发生事件会报错，可捕获，就不会报错：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Click Me"</span> <span class="attr">onclick</span>=<span class="string">"try&#123;showMessage();&#125;catch(ex)&#123;&#125;"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>DOM0 级事件处理程序</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	alert(<span class="string">"Clicked"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">btn.onclick = <span class="literal">null</span>; <span class="comment">//删除事件处理程序</span></span><br></pre></td></tr></table></figure>
<p>以这种方式添加的事件处理程序会在事件流的冒泡阶段被处理。也可以删除通过DOM0 级方法指定的事件处理程序</p>
<ul>
<li>DOM2 级事件处理程序</li>
</ul>
<p>addEventListener()和removeEventListener()。所有DOM节点中都包含这两个方法，并且它们都接受3个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。使用DOM2级方法添加事件处理程序的主要好处是可以添加多个事件处理程序，这两个事件处理程序会按照添加它们的顺序触发。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">btn.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	alert(<span class="keyword">this</span>.id);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure></p>
<p>大多数情况下，都是将事件处理程序添加到事件流的冒泡阶段，这样可以最大限度地兼容各种浏览<br>器。最好只在需要在事件到达目标之前截获它的时候将事件处理程序添加到捕获阶段。如果不是特别需<br>要，我们不建议在事件捕获阶段注册事件处理程序。IE9、Firefox、Safari、Chrome 和Opera 支持DOM2 级事件处理程序。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保存到变量方便删除</span></span><br><span class="line"><span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	alert(<span class="keyword">this</span>.id);</span><br><span class="line">&#125;;</span><br><span class="line">btn.addEventListener(<span class="string">"click"</span>, handler, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">//这里省略了其他代码</span></span><br><span class="line">btn.removeEventListener(<span class="string">"click"</span>, handler, <span class="literal">false</span>); <span class="comment">//有效！</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>IE事件处理程序</li>
</ul>
<p>IE 实现了与DOM 中类似的两个方法：attachEvent()和detachEvent()。这两个方法接受相同的两个参数：事件处理程序名称与事件处理程序函数。由于IE8及更早版本只支持事件冒泡，所以通过attachEvent()添加的事件处理程序都会被添加到冒泡阶段，也可绑定多次，与DOM方法不同的是，这些事件处理程序不是以添加它们的顺序执行，而是以相反的顺序被触发。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数带on</span></span><br><span class="line">btn.attachEvent(<span class="string">"onclick"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">"Clicked"</span>);</span><br><span class="line">	alert(<span class="keyword">this</span> === <span class="built_in">window</span>); <span class="comment">//true，在全局作用域中运行</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">btn.detachEvent(<span class="string">"onclick"</span>, handler);  <span class="comment">// 移事事件绑定</span></span><br></pre></td></tr></table></figure>
<ul>
<li>跨浏览器的事件处理程序</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 法属于一个名叫EventUtil 的对象</span></span><br><span class="line"><span class="keyword">var</span> EventUtil = &#123;</span><br><span class="line">	addHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (element.addEventListener) &#123;</span><br><span class="line">			element.addEventListener(type, handler, <span class="literal">false</span>);  <span class="comment">//DOM2级</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</span><br><span class="line">			element.attachEvent(<span class="string">"on"</span> + type, handler);  <span class="comment">//IE</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			element[<span class="string">"on"</span> + type] = handler;  <span class="comment">//DOM0级</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	removeHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (element.removeEventListener) &#123;</span><br><span class="line">			element.removeEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.detachEvent) &#123;</span><br><span class="line">			element.detachEvent(<span class="string">"on"</span> + type, handler);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			element[<span class="string">"on"</span> + type] = <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>addHandler()和removeHandler()没有考虑到所有的浏览器问题，例如在IE中的作用域问题。不过，使用它们添加和移除事件处理程序还是足够了。此外还要注意，DOM0 级对每个事件只支持一个事件处理程序。</p>
<h5 id="【13-3-事件对象】"><a href="#【13-3-事件对象】" class="headerlink" title="【13.3 事件对象】"></a>【13.3 事件对象】</h5><ul>
<li>DOM中的事件对象</li>
</ul>
<p>兼容DOM 的浏览器会将一个event 对象传入到事件处理程序中。无论指定事件处理程序时使用什么方法（DOM0 级或DOM2 级），都会传入event 对象。在事件处理程序内部，对象this 始终等于currentTarget（其事件处理程序当前正在处理事件的那个元素） 的值，而target（引发事件的目标）则只包含事件的实际目标。如果直接将事件处理程序指定给了目标元素，则this、currentTarget和target包含相同的值。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">	alert(event.currentTarget === <span class="keyword">this</span>); <span class="comment">//true</span></span><br><span class="line">	alert(event.target === <span class="keyword">this</span>); <span class="comment">//true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如果事件处理程序存在于按钮的父节点中（例如document.body），那么这些值是不相同的。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">	alert(event.currentTarget === <span class="built_in">document</span>.body); <span class="comment">//true</span></span><br><span class="line">	alert(<span class="keyword">this</span> === <span class="built_in">document</span>.body); <span class="comment">//true</span></span><br><span class="line">	alert(event.target === <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>)); <span class="comment">//true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在需要通过一个函数处理多个事件时，可以使用type 属性：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line"><span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 发生事件时判断事件类型</span></span><br><span class="line">	<span class="keyword">switch</span> (event.type) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">"click"</span>:</span><br><span class="line">			alert(<span class="string">"Clicked"</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">"mouseover"</span>:</span><br><span class="line">			event.target.style.backgroundColor = <span class="string">"red"</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">"mouseout"</span>:</span><br><span class="line">			event.target.style.backgroundColor = <span class="string">""</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">btn.onclick = handler;</span><br><span class="line">btn.onmouseover = handler;</span><br><span class="line">btn.onmouseout = handler;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">link.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">	event.preventDefault(); <span class="comment">//阻止默认行为</span></span><br><span class="line">	event.stopPropagation(); <span class="comment">//阻止冒泡</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>事件对象的eventPhase 属性，可以用来确定事件当前正位于事件流的哪个阶段。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">	alert(event.eventPhase); <span class="comment">//2,事件处理程序处于目标对象</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">	alert(event.eventPhase); <span class="comment">//1,捕获阶段</span></span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">	alert(event.eventPhase); <span class="comment">//3，冒泡阶段</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>IE中的事件对象</li>
</ul>
<p>在使用DOM0 级方法添加事件处理程序时，event 对象作为window 对象的一个属性存在。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> event = <span class="built_in">window</span>.event;</span><br><span class="line">	alert(event.type); <span class="comment">//"click"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如果事件处理程序是使用attachEvent()添加的，那么就会有一个event 对象作为参数被传入事件处理程序函数中<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">btn.attachEvent(<span class="string">"onclick"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">	alert(event.type); <span class="comment">//"click"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>属性/方法</th>
<th>类 型</th>
<th>读/写</th>
<th>说 明</th>
</tr>
</thead>
<tbody>
<tr>
<td>cancelBubble</td>
<td>Boolean</td>
<td>读/写</td>
<td>默认值为false，但将其设置为true就可以取消事件冒泡（与DOM中</td>
</tr>
</tbody>
</table>
<p>的stopPropagation()方法的作用相同）<br>returnValue | Boolean | 读/写 | 默认值为true，但将其设置为false就可以取消事件的默认行为（与DOM中的preventDefault()方法的作用相同）<br>srcElement | Element | 只读 | 事件的目标（与DOM中的target属性相同）<br>type | String | 只读 | 被触发的事件的类型</p>
<p>因为事件处理程序的作用域是根据指定它的方式来确定的，所以不能认为this会始终等于事件目标。故而，最好还是使用event.srcElement 比较保险。例如：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	alert(<span class="built_in">window</span>.event.srcElement === <span class="keyword">this</span>); <span class="comment">//true</span></span><br><span class="line">&#125;;</span><br><span class="line">btn.attachEvent(<span class="string">"onclick"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">	alert(event.srcElement === <span class="keyword">this</span>); <span class="comment">//false</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>相应地，cancelBubble 属性与DOM 中的stopPropagation()方法作用相同，都是用来停止事件冒泡的。由于IE不支持事件捕获，因而只能取消事件冒泡；但stopPropagatioin()可以同时取消事件捕获和冒泡。例如：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.event.cancelBubble = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>跨浏览器的事件对象</li>
</ul>
<p>可以对前面介绍的EventUtil 对象加以增强，添加如下方法以求同存异。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtil = &#123;</span><br><span class="line">	addHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">		<span class="comment">//省略的代码</span></span><br><span class="line">	&#125;,</span><br><span class="line">	getEvent: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> event ? event : <span class="built_in">window</span>.event;</span><br><span class="line">	&#125;,</span><br><span class="line">	getTarget: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> event.target || event.srcElement;</span><br><span class="line">	&#125;,</span><br><span class="line">	preventDefault: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (event.preventDefault) &#123;</span><br><span class="line">			event.preventDefault();</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			event.returnValue = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	removeHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">		<span class="comment">//省略的代码</span></span><br><span class="line">	&#125;,</span><br><span class="line">	stopPropagation: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (event.stopPropagation) &#123;</span><br><span class="line">			event.stopPropagation();</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用举例</span></span><br><span class="line">link.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">	event = EventUtil.getEvent(event);</span><br><span class="line">	EventUtil.preventDefault(event);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h5 id="【13-4-事件类型】"><a href="#【13-4-事件类型】" class="headerlink" title="【13.4 事件类型】"></a>【13.4 事件类型】</h5><ul>
<li>UI事件</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 是否支持DOM2 级事件规定的HTML 事件：</span></span><br><span class="line"><span class="keyword">var</span> isSupported = <span class="built_in">document</span>.implementation.hasFeature(<span class="string">"HTMLEvents"</span>, <span class="string">"2.0"</span>);</span><br><span class="line"><span class="comment">// 是否支持DOM3事件 </span></span><br><span class="line"><span class="keyword">var</span> isSupported = <span class="built_in">document</span>.implementation.hasFeature(<span class="string">"UIEvent"</span>, <span class="string">"3.0"</span>);</span><br></pre></td></tr></table></figure>
<p><em>1.onload事件</em></p>
<p>同样的功能也可以通过使用DOM0级的Image对象实现。在DOM出现之前，开发人员经常使用Image对象在客户端预先加载图像。可以像使用<code>&lt;img&gt;</code>元素一样使用Image 对象，只不过无法将其添加到DOM 树中。在设置了src就会加载，不一定要插入到文档中。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">"load"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> image = <span class="keyword">new</span> Image();</span><br><span class="line">	EventUtil.addHandler(image, <span class="string">"load"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">		alert(<span class="string">"Image loaded!"</span>);</span><br><span class="line">	&#125;);</span><br><span class="line">	image.src = <span class="string">"smile.gif"</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>在不属于DOM 文档的图像（包括未添加到文档的<code>&lt;img&gt;</code>元素和Image对象）上触发load事件时，IE8及之前版本不会生成event 对象。IE8 及更早版本不支持<code>&lt;script&gt;</code>元素上的load 事件。</p>
<p><em>2.unload事件</em></p>
<p>与load 事件对应的是unload事件，这个事件在文档被完全卸载后触发。只要用户从一个页面切换到另一个页面，就会发生unload 事件。而利用这个事件最多的情况是清除引用，以避免内存泄漏。</p>
<p><em>3.resize事件</em></p>
<p>与其他发生在window 上的事件类似，在兼容DOM的浏览器中，传入事件处理程序中的event对象有一个target属性，值为document；而IE8 及之前版本则未提供任何属性。</p>
<p>关于何时会触发resize 事件，不同浏览器有不同的机制。IE、Safari、Chrome 和Opera 会在浏览器窗口变化了1 像素时就触发resize事件，然后随着变化不断重复触发。Firefox只会在用户停止调整窗口大小时才会触发resize事件。所以避免计算量大的代码影响性能。</p>
<p><em>4.scroll事件</em></p>
<p>在混杂模式下，可以通过<code>&lt;body&gt;</code>元素的scrollLeft和scrollTop来监控到这一变化；而在标准模式下，除Safari之外的所有浏览器都会通过<code>&lt;html&gt;</code>元素来反映这一变化（Safari 仍然基于<code>&lt;body&gt;</code>跟踪滚动位置）<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">"scroll"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">document</span>.compatMode == <span class="string">"CSS1Compat"</span>) &#123;</span><br><span class="line">		alert(<span class="built_in">document</span>.documentElement.scrollTop);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		alert(<span class="built_in">document</span>.body.scrollTop);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<ul>
<li>焦点事件 </li>
</ul>
<p>这一类事件中最主要的两个是focus和blur，它们都是JavaScript早期就得到所有浏览器支持的事件。这些事件的最大问题是它们不冒泡。。因此，IE的focusin和focusout与Opera的DOMFocusIn和DOMFocusOut才会发生重叠。IE的方式最后被DOM3 级事件采纳为标准方式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检测是否支持这些事件</span></span><br><span class="line"><span class="keyword">var</span> isSupported = <span class="built_in">document</span>.implementation.hasFeature(<span class="string">"FocusEvent"</span>, <span class="string">"3.0"</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>鼠标与滚轮事件</li>
</ul>
<p>IE8 及之前版本中的实现有一个小bug，因此在双击事件中，会跳过第二个mousedown和click事件。使用以下代码可以检测浏览器是否支持以上DOM2 级事件（除dbclick、mouseenter 和<br>mouseleave 之外）：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DOM2</span></span><br><span class="line"><span class="keyword">var</span> isSupported = <span class="built_in">document</span>.implementation.hasFeature(<span class="string">"MouseEvents"</span>, <span class="string">"2.0"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测DOM3支持性</span></span><br><span class="line"><span class="keyword">var</span> isSupported = <span class="built_in">document</span>.implementation.hasFeature(<span class="string">"MouseEvent"</span>, <span class="string">"3.0"</span>)</span><br></pre></td></tr></table></figure></p>
<p>DOM3新增事件属性pageX和pageY属性，，这两个属性表示鼠标光标在页面中的位置而非视口，但IE8不兼容。这时候需要用到document.body（混杂模式）或document.documentElement（标准模式）中的scrollLeft 和scrollTop 属性。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</span><br><span class="line">EventUtil.addHandler(div, <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">	event = EventUtil.getEvent(event);</span><br><span class="line">	<span class="keyword">var</span> pageX = event.pageX,</span><br><span class="line">		pageY = event.pageY;</span><br><span class="line">	<span class="keyword">if</span> (pageX === <span class="literal">undefined</span>) &#123;</span><br><span class="line">		pageX = event.clientX + (<span class="built_in">document</span>.body.scrollLeft ||</span><br><span class="line">			<span class="built_in">document</span>.documentElement.scrollLeft);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (pageY === <span class="literal">undefined</span>) &#123;</span><br><span class="line">		pageY = event.clientY + (<span class="built_in">document</span>.body.scrollTop ||</span><br><span class="line">			<span class="built_in">document</span>.documentElement.scrollTop);</span><br><span class="line">	&#125;</span><br><span class="line">	alert(<span class="string">"Page coordinates: "</span> + pageX + <span class="string">","</span> + pageY);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><em>1.相关元素</em></p>
<p>如果鼠标指针一开始位于这个<code>&lt;div&gt;</code>元素上，然后移出了这个元素，那么就会在<code>&lt;div&gt;</code>元素上触发mouseout事件，相关元素就是<code>&lt;body&gt;</code>元素。</p>
<p>DOM通过event 对象的relatedTarget 属性提供了相关元素的信息。这个属性只对于mouseover和mouseout事件才包含值；对于其他事件，这个属性的值是null。IE8及之前版本不支持relatedTarget属性，但提供了保存着同样信息的不同属性。在mouseover 事件触发时，IE 的fromElement 属性中保存了相关元素；在mouseout 事件触发时，IE的toElement 属性中保存着相关元素。（IE9支持所有这些属性。）可以把下面这个跨浏览器取得相关元素的方法添加到EventUtil对象中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtil = &#123;</span><br><span class="line">	<span class="comment">//省略了其他代码</span></span><br><span class="line">	getRelatedTarget: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (event.relatedTarget) &#123;</span><br><span class="line">			<span class="keyword">return</span> event.relatedTarget;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.toElement) &#123;</span><br><span class="line">			<span class="keyword">return</span> event.toElement;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.fromElement) &#123;</span><br><span class="line">			<span class="keyword">return</span> event.fromElement;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">//省略了其他代码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><em>2.    鼠标按钮</em></p>
<p>只有在主鼠标按钮被单击（或键盘回车键被按下）时才会触发click 事件，对于mousedown 和mouseup 事件来说，则在其event 对象存在一个button 属性，<br>表示按下或释放的按钮。DOM的button 属性可能有如下3 个值：0 表示主鼠标按钮，1 表示中间的鼠<br>标按钮（鼠标滚轮按钮），2 表示次鼠标按钮。在常规的设置中，主鼠标按钮就是鼠标左键，而次鼠标<br>按钮就是鼠标右键。</p>
<p>IE8 及之前版本也提供了button 属性，但这个属性的值与DOM 的button 属性有很大差异。<br> 0：表示没有按下按钮。<br> 1：表示按下了主鼠标按钮。<br> 2：表示按下了次鼠标按钮。<br> 3：表示同时按下了主、次鼠标按钮。<br> 4：表示按下了中间的鼠标按钮。<br> 5：表示同时按下了主鼠标按钮和中间的鼠标按钮。<br> 6：表示同时按下了次鼠标按钮和中间的鼠标按钮。<br> 7：表示同时按下了三个鼠标按钮。</p>
<p>由于单独使用能力检测无法确定差异（两种模型有同名的button属性），因此必须另辟蹊径。我们知道，支持DOM版鼠标事件的浏览器可以通过hasFearture()方法来检测</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtil = &#123;</span><br><span class="line">	<span class="comment">//省略了其他代码</span></span><br><span class="line">	getButton: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">document</span>.implementation.hasFeature(<span class="string">"MouseEvents"</span>, <span class="string">"2.0"</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> event.button;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">switch</span> (event.button) &#123;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">				<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">				<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">				<span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">				<span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">					<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">				<span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">					<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">					<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">//省略了其他代码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><em>3.鼠标滚轮事件</em></p>
<p>这个事件可以在任何元素上面触发，最终会冒泡到document（IE8）或window（IE9、Opera、Chrome及Safari）对象。与mousewheel事件对应的event对象除包含鼠标事件的所有标准信息外，还包含一个特殊的wheelDelta属性，是120的倍数，向上滚动为正，但在Opera 9.5之前的版本中，wheelDelta值的正负号是颠倒的。Firefox支持一个名为DOMMouseScroll的类似事件<br>，信息保存在detail属性中，是-3的倍数，好方向与wheelDelta相反。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtil = &#123;</span><br><span class="line">	<span class="comment">//省略了其他代码</span></span><br><span class="line">	getWheelDelta: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (event.wheelDelta) &#123;</span><br><span class="line">			<span class="keyword">return</span> (client.engine.opera &amp;&amp; client.engine.opera &lt; <span class="number">9.5</span> ?</span><br><span class="line">				-event.wheelDelta : event.wheelDelta);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> -event.detail * <span class="number">40</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">//省略了其他代码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>键盘和文本事件</li>
</ul>
<p>IE9、Firefox、Chrome 和Safari 的event 对象都支持一个charCode 属性，这个属性只有在发生<br>keypress 事件时才包含值，而且这个值是按下的那个键所代表字符的ASCII 编码。此时的keyCode<br>通常等于0 或者也可能等于所按键的键码。IE8 及之前版本和Opera 则是在keyCode 中保存字符的ASCII<br>编码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtil = &#123;</span><br><span class="line">	<span class="comment">//省略的代码</span></span><br><span class="line">	getCharCode: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">typeof</span> event.charCode == <span class="string">"number"</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> event.charCode;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> event.keyCode;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">//省略的代码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>变动事件</li>
</ul>
<p>DOM2 级的变动（mutation）事件能在DOM 中的某一部分发生变化时给出提示。变动事件是为XML或HTMLDOM设计的，并不特定于某种语言。DOM2级定义了如下变动事件。如DOMSubtreeModified：在DOM结构中发生任何变化时触发。这个事件在其他任何事件触发后都会触发。</p>
<ul>
<li>HTML5事件</li>
</ul>
<p><em>1.contextmenu事件</em></p>
<p>在所有浏览器中都可以取消这个事件：在兼容DOM的浏览器中，使用event.preventDefalut()；在IE 中，将event.returnValue 的值设置为false。主流浏览器全兼容</p>
<p>自中键菜单：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">"load"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</span><br><span class="line">	EventUtil.addHandler(div, <span class="string">"contextmenu"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">		event = EventUtil.getEvent(event);</span><br><span class="line">		EventUtil.preventDefault(event);</span><br><span class="line">		<span class="keyword">var</span> menu = <span class="built_in">document</span>.getElementById(<span class="string">"myMenu"</span>);</span><br><span class="line">		menu.style.left = event.clientX + <span class="string">"px"</span>;</span><br><span class="line">		menu.style.top = event.clientY + <span class="string">"px"</span>;</span><br><span class="line">		menu.style.visibility = <span class="string">"visible"</span>;</span><br><span class="line">	&#125;);</span><br><span class="line">	EventUtil.addHandler(<span class="built_in">document</span>, <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">		<span class="built_in">document</span>.getElementById(<span class="string">"myMenu"</span>).style.visibility = <span class="string">"hidden"</span>;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><em>2.beforeunload事件</em></p>
<p>这个事件会在浏览器卸载页面之前触发，可以通过它来取消卸载并继续使用原有页面。为了显示弹出对话框，必须将event.returnValue的值设置为要显示给用户的字符串（对IE及Fiefox而言），同时作为函数的值返回（对Safari和Chrome 而言），如下面的例子所示。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">"beforeunload"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">	event = EventUtil.getEvent(event);</span><br><span class="line">	<span class="keyword">var</span> message = <span class="string">"I'm really going to miss you if you go."</span>;</span><br><span class="line">	event.returnValue = message;</span><br><span class="line">	<span class="keyword">return</span> message;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><em>3.DOMContentLoaded事件</em></p>
<p>DOMContentLoaded 事件则在形成完整的DOM 树之后就会触发，不理会图像、JavaScript文件、CSS文件或其他资源是否已经下载完毕。与load事件不同，DOMContentLoaded支持在页面下载的早期添加事件处理程序，这也就意味着用户能够尽早地与页面进行交互，这个事件始终都会在load 事件之前触发。不兼容IE8及以下。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">EventUtil.addHandler(<span class="built_in">document</span>, <span class="string">"DOMContentLoaded"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">"Content loaded"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>对于不支持DOMContentLoaded 的浏览器，我们建议在页面加载期间设置一个时间为0 毫秒的超时调用：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">//在此添加事件处理程序</span></span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>在页面下载和构建期间，只有一个JavaScript处理过程，因此超时调用会在该过程结束时立即触发。至于这个时间与DOMContentLoaded 被触发的时间能否同步，主要还是取决于用户使用的浏览器和页面中的其他代码。为了确保这个方法有效，必须将其作为页面中的第一个超时调用；即便如此，也还是无法保证在所有环境中该超时调用一定会早于load事件被触发。</p>
<p><em>4.hashchange</em></p>
<p>HTML5 新增了hashchange 事件，以便在URL 的参数列表（及URL 中“#”号后面的所有字符串）<br>发生变化时通知开发人员。必须要把hashchange事件处理程序添加给window对象，然后URL参数列表只要变化就会调用它。此时的event对象应该额外包含两个属性：oldURL和newURL。这两个属性分别保存着参数列表变化前后的完整URL。支持hashchange 事件的浏览器有IE8+、Firefox 3.6+、Safari 5+、Chrome 和Opera 10.6+。在这些浏览器中，只有Firefox 6+、Chrome和Opera支持oldURL和newURL属性。为此，最好是使用location对象来确定当前的参数列表。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//检测是否支持hashchange事件</span></span><br><span class="line"><span class="keyword">var</span> isSupported = (<span class="string">"onhashchange"</span> <span class="keyword">in</span> <span class="built_in">window</span>); <span class="comment">//这里有bug</span></span><br></pre></td></tr></table></figure></p>
<p>如果IE8 是在IE7文档模式下运行，即使功能无效它也会返回true。为解决这个问题，可以使用以下这个更稳妥的检测方式：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isSupported = (<span class="string">"onhashchange"</span> <span class="keyword">in</span> <span class="built_in">window</span>) &amp;&amp; (<span class="built_in">document</span>.documentMode ===</span><br><span class="line"><span class="literal">undefined</span> || <span class="built_in">document</span>.documentMode &gt; <span class="number">7</span>);</span><br></pre></td></tr></table></figure></p>
<h5 id="【13-5-内存和性能】"><a href="#【13-5-内存和性能】" class="headerlink" title="【13.5 内存和性能】"></a>【13.5 内存和性能】</h5><ul>
<li>事件委托<br>对“事件处理程序过多”问题的解决方案就是事件委托。事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。如对下面的li绑定点击事件：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"myLinks"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"goSomewhere"</span>&gt;</span>Go somewhere<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"doSomething"</span>&gt;</span>Do something<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"sayHi"</span>&gt;</span>Say hi<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>此时，可以利用事件委托技术解决这个问题。使用事件委托，只需在DOM 树中尽量最高的层次上添加一个事件处理程序<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="built_in">document</span>.getElementById(<span class="string">"myLinks"</span>);</span><br><span class="line">EventUtil.addHandler(list, <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">	event = EventUtil.getEvent(event);</span><br><span class="line">	<span class="keyword">var</span> target = EventUtil.getTarget(event);</span><br><span class="line">	<span class="keyword">switch</span> (target.id) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">"doSomething"</span>:</span><br><span class="line">			<span class="built_in">document</span>.title = <span class="string">"I changed the document's title"</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">"goSomewhere"</span>:</span><br><span class="line">			location.href = <span class="string">"http://www.wrox.com"</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">"sayHi"</span>:</span><br><span class="line">			alert(<span class="string">"hi"</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>最适合采用事件委托技术的事件包括click、mousedown、mouseup、keydown、keyup 和keypress。</p>
<ul>
<li>移除事件处理程序</li>
</ul>
<p>如果带有事件处理程序的元素被innerHTML或通过纯粹的DOM操作，例如使用removeChild()和replaceChild()方法删除了，那么原来添加到元素中的事件处理程序极有可能无法被当作垃圾回收。所以应在删除之前删除事件绑定以便释放内存。采用事件委托也有助于解决这个问题。</p>
<h5 id="【13-6-模拟事件】"><a href="#【13-6-模拟事件】" class="headerlink" title="【13.6 模拟事件】"></a>【13.6 模拟事件】</h5><ul>
<li>DOM中的事件模拟</li>
</ul>
<p><em>1.模拟鼠标事件</em><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line"><span class="comment">//创建事件对象</span></span><br><span class="line"><span class="keyword">var</span> event = <span class="built_in">document</span>.createEvent(<span class="string">"MouseEvents"</span>);</span><br><span class="line"><span class="comment">//初始化事件对象</span></span><br><span class="line">event.initMouseEvent(<span class="string">"click"</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="built_in">document</span>.defaultView, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">	<span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">//触发事件</span></span><br><span class="line">btn.dispatchEvent(event);</span><br></pre></td></tr></table></figure></p>
<p>在兼容DOM的浏览器中，也可以通过相同的方式来模拟其他鼠标事件（例如dblclick）。</p>
<p><em>2.模拟键盘事件</em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//只适用于Firefox</span></span><br><span class="line"><span class="keyword">var</span> textbox = <span class="built_in">document</span>.getElementById(<span class="string">"myTextbox"</span>)</span><br><span class="line">	<span class="comment">//创建事件对象</span></span><br><span class="line"><span class="keyword">var</span> event = <span class="built_in">document</span>.createEvent(<span class="string">"KeyEvents"</span>);</span><br><span class="line"><span class="comment">//初始化事件对象</span></span><br><span class="line">event.initKeyEvent(<span class="string">"keypress"</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="built_in">document</span>.defaultView, <span class="literal">false</span>, <span class="literal">false</span>,</span><br><span class="line">	<span class="literal">false</span>, <span class="literal">false</span>, <span class="number">65</span>, <span class="number">65</span>);</span><br><span class="line"><span class="comment">//触发事件</span></span><br><span class="line">textbox.dispatchEvent(event);</span><br></pre></td></tr></table></figure>
<p>在Firefox 中运行上面的代码，会在指定的文本框中输入字母A。同样，也可以依此模拟keyup 和keydown 事件。<br>在其他浏览器中，则需要创建一个通用的事件，然后再向事件对象中添加键盘事件特有的信息。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> textbox = <span class="built_in">document</span>.getElementById(<span class="string">"myTextbox"</span>);</span><br><span class="line"><span class="comment">//创建事件对象</span></span><br><span class="line"><span class="keyword">var</span> event = <span class="built_in">document</span>.createEvent(<span class="string">"Events"</span>);</span><br><span class="line"><span class="comment">//初始化事件对象</span></span><br><span class="line">event.initEvent(type, bubbles, cancelable);</span><br><span class="line">event.view = <span class="built_in">document</span>.defaultView;</span><br><span class="line">event.altKey = <span class="literal">false</span>;</span><br><span class="line">event.ctrlKey = <span class="literal">false</span>;</span><br><span class="line">event.shiftKey = <span class="literal">false</span>;</span><br><span class="line">event.metaKey = <span class="literal">false</span>;</span><br><span class="line">event.keyCode = <span class="number">65</span>;</span><br><span class="line">event.charCode = <span class="number">65</span>;</span><br><span class="line"><span class="comment">//触发事件</span></span><br><span class="line">textbox.dispatchEvent(event);</span><br></pre></td></tr></table></figure></p>
<p>在此必须要使用通用事件，而不能使用UI 事件，因为UI 事件不允许向event对象中再添加新属性（Safari除外）。像这样模拟事件虽然会触发键盘事件，但却不会向文本框中写入文本，这是由于无法精确模拟键盘事件所造成的。</p>
<ul>
<li>IE中的事件模拟</li>
</ul>
<p>在调用fireEvent()方法时，会自动为event 对象添加srcElement 和type 属性；其他属性则都是必须通过手工添加的。换句话说，模拟任何IE支持的事件都采用相同的模式。例如，下面的代码模拟了在一个按钮上触发click 事件过程。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line"><span class="comment">//创建事件对象</span></span><br><span class="line"><span class="keyword">var</span> event = <span class="built_in">document</span>.createEventObject();  <span class="comment">//此方法无参数</span></span><br><span class="line"><span class="comment">//初始化事件对象</span></span><br><span class="line">event.screenX = <span class="number">100</span>;</span><br><span class="line">event.screenY = <span class="number">0</span>;</span><br><span class="line">event.clientX = <span class="number">0</span>;</span><br><span class="line">event.clientY = <span class="number">0</span>;</span><br><span class="line">event.ctrlKey = <span class="literal">false</span>;</span><br><span class="line">event.altKey = <span class="literal">false</span>;</span><br><span class="line">event.shiftKey = <span class="literal">false</span>;</span><br><span class="line">event.button = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//触发事件</span></span><br><span class="line">btn.fireEvent(<span class="string">"onclick"</span>, event);</span><br></pre></td></tr></table></figure></p>
<h4 id="十四、表单脚本"><a href="#十四、表单脚本" class="headerlink" title="十四、表单脚本"></a>十四、表单脚本</h4><hr>
<h5 id="【14-1-表单基础】"><a href="#【14-1-表单基础】" class="headerlink" title="【14.1 表单基础】"></a>【14.1 表单基础】</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 通用提交按钮 --&gt;</span><br><span class="line">&lt;input type="submit" value="Submit Form"&gt;</span><br><span class="line">&lt;!-- 自定义提交按钮 --&gt;</span><br><span class="line">&lt;button type="submit"&gt;Submit Form&lt;/button&gt;</span><br><span class="line">&lt;!-- 图像按钮 --&gt;</span><br><span class="line">&lt;input type="image" src="graphic.gif"&gt;</span><br></pre></td></tr></table></figure>
<p>只要表单中存在上面列出的任何一种按钮，那么在相应表单控件拥有焦点的情况下，按回车键就可以提交该表单。（textarea 是一个例外，在文本区中回车会换行。）如果表单里没有提交按钮，按回车键不会提交表单。</p>
<p>在JavaScript 中，以编程方式调用submit()方法也可以提交表单。而且，这种方式无需表单包含提交按钮，任何时候都可以正常提交表单。在以调用submit()方法的形式提交表单时，不会触发submit 事件，因此要记得在调用此方法之前先验证表单数据。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">"myForm"</span>);</span><br><span class="line"><span class="comment">//提交表单</span></span><br><span class="line">form.submit();</span><br><span class="line">form.reset();  <span class="comment">//重置表单</span></span><br></pre></td></tr></table></figure></p>
<p>防止反复提交表单：在第一次提交表单后就禁用提交按钮，或者利用onsubmit 事件处理程序取消后续的表单提交操作。</p>
<p>form表单有一个属性elements保存表单中的所有字段，按出现顺序，如果有多个表单控件都在使用一个name（如单选按钮），那么就会返回以该name 命名的一个<br>NodeList。：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取得表单中的第一个字段</span></span><br><span class="line"><span class="keyword">var</span> field1 = form.elements[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//取得名为"textbox1"的字段</span></span><br><span class="line"><span class="keyword">var</span> field2 = form.elements[<span class="string">"textbox1"</span>];</span><br><span class="line"><span class="comment">//取得表单中包含的字段的数量</span></span><br><span class="line"><span class="keyword">var</span> fieldCount = form.elements.length;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>表单字段</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//避免多次提交表单</span></span><br><span class="line">EventUtil.addHandler(form, <span class="string">"submit"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">	event = EventUtil.getEvent(event);</span><br><span class="line">	<span class="keyword">var</span> target = EventUtil.getTarget(event);</span><br><span class="line">	<span class="comment">//取得提交按钮</span></span><br><span class="line">	<span class="keyword">var</span> btn = target.elements[<span class="string">"submit-btn"</span>];</span><br><span class="line">	<span class="comment">//禁用它</span></span><br><span class="line">	btn.disabled = <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>以上代码为表单的submit 事件添加了一个事件处理程序。事件触发后，代码取得了提交按钮并将其disabled属性设置为true。注意，不能通过onclick事件处理程序来实现这个功能，原因是不同浏览器之间存在“时差”：有的浏览器会在触发表单的submit事件之前触发click事件，而有的浏览器则相反。对于先触发click 事件的浏览器，意味着会在提交发生之前禁用按钮，结果永远都不会提交表单。因此，最好是通过submit 事件来禁用提交按钮。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--多选列表，type属性值为select-multiple--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">multiple</span>&gt;</span>...<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此外，<input>和<button>元素的type 属性是可以动态修改的，而</button><select>元素的type 属性<br>则是只读的。</select></p>
<p>HTML5 为表单字段新增了一个autofocus 属性。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">autofocus</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// autofocus兼容式</span></span><br><span class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">"load"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> element = <span class="built_in">document</span>.forms[<span class="number">0</span>].elements[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">if</span> (element.autofocus !== <span class="literal">true</span>) &#123;</span><br><span class="line">		element.focus();</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"JS focus"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>因为autofocus 是一个布尔值属性，所以在支持的浏览器中它的值应该是true。（在不支持的浏览器中，它的值将是空字符串。在默认情况下，只有表单字段可以获得焦点。对于其他元素而言，如果先将其<br>tabIndex 属性设置为1，然后再调用focus()方法，也可以让这些元素获得焦点。<br>只有Opera 不支持这种技术。</p>
<h5 id="【14-2-文本框脚本】"><a href="#【14-2-文本框脚本】" class="headerlink" title="【14.2 文本框脚本】"></a>【14.2 文本框脚本】</h5><p>如果要创建一个文本框，让它能够显示25 个字符，但输入不能超过50 个字符：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">size</span>=<span class="string">"25"</span> <span class="attr">maxlength</span>=<span class="string">"50"</span> <span class="attr">value</span>=<span class="string">"initial value"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>与<input>元素不同，<textarea>的初始值必须要放在<code>&lt;textarea&gt;</code>和<code>&lt;/textarea&gt;</code>之间。不要使用setAttribute()设置<code>&lt;input&gt;</code>元素的value 特性，也不要去修改</textarea><textarea>元素的第一个子节点。原因很简单：对value属性所作的修改，不一定会反映在DOM中。因此，在处理文本框的值时，最好不要使用DOM 方法。</textarea></p>
<ul>
<li>选择文本</li>
</ul>
<p>上述两种文本框都支持select()方法，这个方法用于选择文本框中的所有文本。在调用select()方法时，大多数浏览器（Opera除外）都会将焦点设置到文本框中。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取焦点时自动选择全部文本</span></span><br><span class="line">EventUtil.addHandler(textbox, <span class="string">"focus"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">	event = EventUtil.getEvent(event);</span><br><span class="line">	<span class="keyword">var</span> target = EventUtil.getTarget(event);</span><br><span class="line">	target.select();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>虽然通过select 事件我们可以知道用户什么时候选择了文本，但仍然不知道用户选择了什么文本。HTML5通过一些扩展方案解决了这个问题，以便更顺利地取得选择的文本。该规范采取的办法是添加两个属性：selectionStart和selectionEnd。IE8及更早的版本中有一个document.selection 对象，其中保存着用户在整个文档范围内选择的文本信息。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取得选择的文本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSelectedText</span>(<span class="params">textbox</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> textbox.selectionStart == <span class="string">"number"</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> textbox.value.substring(textbox.selectionStart,</span><br><span class="line">			textbox.selectionEnd);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">document</span>.selection) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">document</span>.selection.createRange().text;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>选择部分文本，现在除select()方法之外，所有文本框都有一个setSelectionRange()方法。这个方法接收两个参数：要选择的第一个字符的索引和要选择的最后一个字符之后的字符的索引<br>（类似于substring()方法的两个参数）。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">textbox.value = <span class="string">"Hello world!"</span></span><br><span class="line"><span class="comment">//选择所有文本</span></span><br><span class="line">textbox.setSelectionRange(<span class="number">0</span>, textbox.value.length); <span class="comment">//"Hello world!"</span></span><br><span class="line"><span class="comment">//选择前3 个字符</span></span><br><span class="line">textbox.setSelectionRange(<span class="number">0</span>, <span class="number">3</span>); <span class="comment">//"Hel"</span></span><br></pre></td></tr></table></figure></p>
<p>IE8 及更早版本支持使用范围（第12 章讨论过）选择部分文本。要选择文本框中的部分文本，必须<br>首先使用IE 在所有文本框上提供的createTextRange()方法创建一个范围，并将其放在恰当的位置<br>上。然后，再使用moveStart()和moveEnd()这两个范围方法将范围移动到位。不过，在调用这两个<br>方法以前，还必须使用collapse()将范围折叠到文本框的开始位置。此时，moveStart()将范围的起<br>点和终点移动到了相同的位置，只要再给moveEnd()传入要选择的字符总数即可。最后一步，就是使<br>用范围的select()方法选择文本，如下面的例子所示。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//选择第4 到第6 个字符</span></span><br><span class="line">range.collapse(<span class="literal">true</span>);</span><br><span class="line">range.moveStart(<span class="string">"character"</span>, <span class="number">4</span>);</span><br><span class="line">range.moveEnd(<span class="string">"character"</span>, <span class="number">3</span>);</span><br><span class="line">range.select(); <span class="comment">//"o w"</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 选择部分文本兼容式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectText</span>(<span class="params">textbox, startIndex, stopIndex</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (textbox.setSelectionRange) &#123;</span><br><span class="line">		textbox.setSelectionRange(startIndex, stopIndex);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (textbox.createTextRange) &#123;</span><br><span class="line">		<span class="keyword">var</span> range = textbox.createTextRange();</span><br><span class="line">		range.collapse(<span class="literal">true</span>);</span><br><span class="line">		range.moveStart(<span class="string">"character"</span>, startIndex);</span><br><span class="line">		range.moveEnd(<span class="string">"character"</span>, stopIndex - startIndex);</span><br><span class="line">		range.select();</span><br><span class="line">	&#125;</span><br><span class="line">	textbox.focus();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>过滤输入</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 屏蔽所有键盘操作</span></span><br><span class="line">EventUtil.addHandler(textbox, <span class="string">"keypress"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">	event = EventUtil.getEvent(event);</span><br><span class="line">	EventUtil.preventDefault(event);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只允许输入数值</span></span><br><span class="line">EventUtil.addHandler(textbox, <span class="string">"keypress"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">	event = EventUtil.getEvent(event);</span><br><span class="line">	<span class="keyword">var</span> target = EventUtil.getTarget(event);</span><br><span class="line">	<span class="keyword">var</span> charCode = EventUtil.getCharCode(event);</span><br><span class="line">	<span class="keyword">if</span> (!<span class="regexp">/\d/</span>.test(<span class="built_in">String</span>.fromCharCode(charCode))) &#123;</span><br><span class="line">		EventUtil.preventDefault(event);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在Firefox 中，所<br>有由非字符键触发的keypress 事件对应的字符编码为0，而在Safari 3 以前的版本中，对应的字符编<br>码全部为8。为了让代码更通用，只要不屏蔽那些字符编码小于10 的键即可。除此之外，还有一个问题需要处理：复制、粘贴及其他操作还要用到Ctrl 键。在除IE 之外的所有<br>浏览器中，前面的代码也会屏蔽Ctrl+C、Ctrl+V，以及其他使用Ctrl 的组合键。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">EventUtil.addHandler(textbox, <span class="string">"keypress"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">	event = EventUtil.getEvent(event);</span><br><span class="line">	<span class="keyword">var</span> target = EventUtil.getTarget(event);</span><br><span class="line">	<span class="keyword">var</span> charCode = EventUtil.getCharCode(event);</span><br><span class="line">	<span class="keyword">if</span> (!<span class="regexp">/\d/</span>.test(<span class="built_in">String</span>.fromCharCode(charCode)) &amp;&amp; charCode &gt; <span class="number">9</span> &amp;&amp;</span><br><span class="line">		!event.ctrlKey) &#123;</span><br><span class="line">		EventUtil.preventDefault(event);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<ul>
<li>操作剪贴板</li>
</ul>
<p>HTML 5 后来也把剪贴板事件纳入了规范。下列就是6 个剪贴板事件。</p>
<p> beforecopy：在发生复制操作前触发。<br> copy：在发生复制操作时触发。<br> beforecut：在发生剪切操作前触发。<br> cut：在发生剪切操作时触发。<br> beforepaste：在发生粘贴操作前触发。<br> paste：在发生粘贴操作时触发。</p>
<p>要访问剪贴板中的数据，可以使用clipboardData 对象：在IE 中，这个对象是window 对象的<br>属性；而在Firefox 4+、Safari 和Chrome 中，这个对象是相应event 对象的属性。但是，在Firefox、<br>Safari 和Chorme 中，只有在处理剪贴板事件期间clipboardData 对象才有效，这是为了防止对剪贴板<br>的未授权访问；在IE 中，则可以随时访问clipboardData 对象。为了确保跨浏览器兼容性，最好只<br>在发生剪贴板事件期间使用这个对象。</p>
<p>这个clipboardData 对象有三个方法：getData()、setData()和clearData()。其中，getData()<br>用于从剪贴板中取得数据，它接受一个参数，即要取得的数据的格式。在IE 中，有两种数据格式：”text”<br>和”URL”。在Firefox、Safari 和Chrome 中，这个参数是一种MIME 类型；不过，可以用”text”代表<br>“text/plain”。</p>
<p>类似地，setData()方法的第一个参数也是数据类型，第二个参数是要放在剪贴板中的文本。对于<br>第一个参数，IE 照样支持”text”和”URL”，而Safari 和Chrome 仍然只支持MIME 类型。但是，与<br>getData()方法不同的是，Safari 和Chrome 的setData()方法不能识别”text”类型。这两个浏览器在<br>成功将文本放到剪贴板中后，都会返回true；否则，返回false。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtil = &#123;</span><br><span class="line">	<span class="comment">//省略的代码</span></span><br><span class="line">	getClipboardText: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> clipboardData = (event.clipboardData || <span class="built_in">window</span>.clipboardData);</span><br><span class="line">		<span class="keyword">return</span> clipboardData.getData(<span class="string">"text"</span>);</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">//省略的代码</span></span><br><span class="line">	setClipboardText: <span class="function"><span class="keyword">function</span>(<span class="params">event, value</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (event.clipboardData) &#123;</span><br><span class="line">			<span class="keyword">return</span> event.clipboardData.setData(<span class="string">"text/plain"</span>, value);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.clipboardData) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">window</span>.clipboardData.setData(<span class="string">"text"</span>, value);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">//省略的代码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>。例如，如果一个文本框只接受数值，那么就必须检测粘贴过来的值，以确保有效。在paste<br>事件中，可以确定剪贴板中的值是否有效，如果无效，就可以像下面示例中那样，取消默认的行为。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">EventUtil.addHandler(textbox, <span class="string">"paste"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">	event = EventUtil.getEvent(event);</span><br><span class="line">	<span class="keyword">var</span> text = EventUtil.getClipboardText(event);</span><br><span class="line">	<span class="keyword">if</span> (!<span class="regexp">/^\d*$/</span>.test(text)) &#123;</span><br><span class="line">		EventUtil.preventDefault(event);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<ul>
<li>自动切换焦点</li>
</ul>
<p>// 当文本框的字符数超过maxLength时自动跳到下一个表单<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tabForward</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">	event = EventUtil.getEvent(event);</span><br><span class="line">	<span class="keyword">var</span> target = EventUtil.getTarget(event);</span><br><span class="line">	<span class="keyword">if</span> (target.value.length == target.maxLength) &#123;</span><br><span class="line">		<span class="keyword">var</span> form = target.form;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = form.elements.length; i &lt; len; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (form.elements[i] == target) &#123;</span><br><span class="line">				<span class="keyword">if</span> (form.elements[i + <span class="number">1</span>]) &#123;</span><br><span class="line">					form.elements[i + <span class="number">1</span>].focus();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">EventUtil.addHandler(textbox1, <span class="string">"keyup"</span>, tabForward);  <span class="comment">// 调用tabForward</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>HTML5 约束验证API</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">"text"</span> name=<span class="string">"username"</span> required&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查是否支持required</span></span><br><span class="line"><span class="keyword">var</span> isRequiredSupported = <span class="string">"required"</span> <span class="keyword">in</span> <span class="built_in">document</span>.createElement(<span class="string">"input"</span>);</span><br><span class="line"><span class="comment">//检查required是否填写</span></span><br><span class="line"><span class="keyword">var</span> isUsernameRequired = <span class="built_in">document</span>.forms[<span class="number">0</span>].elements[<span class="string">"username"</span>].required;</span><br></pre></td></tr></table></figure>
<p>“email”类型要求输入的文本必须符合电子邮件地址的模式，而”url”类型要求输入的文本必须符合URL 的模式。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">"email"</span> name =<span class="string">"email"</span>&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"url"</span> <span class="attr">name</span>=<span class="string">"homepage"</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>检测是否支持email类型,不支持它们的旧版本浏览器会自动将未知的值设置为”text”，而支持的浏览器则会返回正确的值。例如：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> input = <span class="built_in">document</span>.createElement(<span class="string">"input"</span>);</span><br><span class="line">input.type = <span class="string">"email"</span>;</span><br><span class="line"><span class="keyword">var</span> isEmailSupported = (input.type == <span class="string">"email"</span>);</span><br></pre></td></tr></table></figure></p>
<p>使用checkValidity()方法可以检测表单中的某个字段是否有效。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.forms[<span class="number">0</span>].elements[<span class="number">0</span>].checkValidity()) &#123;</span><br><span class="line">	<span class="comment">//字段有效，继续</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">//字段无效</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检测整个表单</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">document</span>.forms[<span class="number">0</span>].checkValidity())&#123;</span><br><span class="line"><span class="comment">//表单有效，继续</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//表单无效</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过设置novalidate 属性，可以告诉表单不进行验证。</span></span><br><span class="line">&lt;form method=<span class="string">"post"</span> action=<span class="string">"signup.php"</span> novalidate&gt;</span><br><span class="line"><span class="xml"><span class="comment">&lt;!--这里插入表单元素--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.forms[<span class="number">0</span>].noValidate = <span class="literal">true</span>; <span class="comment">//禁用验证</span></span><br></pre></td></tr></table></figure>
<h5 id="【14-3-选择框脚本】"><a href="#【14-3-选择框脚本】" class="headerlink" title="【14.3 选择框脚本】"></a>【14.3 选择框脚本】</h5><p>选择框是通过<select>和<option>元素创建的。为了方便与这个控件交互，除了所有表单字段共有的属性和方法外，HTMLSelectElement类型还提供了下列属性和方法。</option></select></p>
<p> add(newOption, relOption)：向控件中插入新<option>元素，其位置在相关项（relOption）<br>之前。<br> multiple：布尔值，表示是否允许多项选择；等价于HTML 中的multiple 特性。<br> options：控件中所有</option><option>元素的HTMLCollection。<br> remove(index)：移除给定位置的选项。<br> selectedIndex：基于0 的选中项的索引，如果没有选中项，则值为-1。对于支持多选的控件，<br>只保存选中项中第一项的索引。<br> size：选择框中可见的行数；等价于HTML 中的size 特性。</option></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//推荐，取得了选择框中第一项的文本和值</span></span><br><span class="line"><span class="keyword">var</span> text = selectbox.options[<span class="number">0</span>].text; <span class="comment">//选项的文本</span></span><br><span class="line"><span class="keyword">var</span> value = selectbox.options[<span class="number">0</span>].value; <span class="comment">//选项的值</span></span><br></pre></td></tr></table></figure>
<ul>
<li>选择选项</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> selectedOption = selectbox.options[selectbox.selectedIndex]; <span class="comment">//取得选中项</span></span><br></pre></td></tr></table></figure>
<p>对于可以选择多项的选择框，selectedfIndex属性就好像只允许选择一项一样。设置selectedIndex会导致取消以前的所有选项并选择指定的那一项，而读取selectedIndex则只会返回选中项中第一项的索引值。另一种选择选项的方式，就是取得对某一项的引用，然后将其selected 属性设置为true。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">selectbox.options[<span class="number">0</span>].selected = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></p>
<p>实际上，selected 属性的作用主要是确定用户选择了选择框中的哪一项。要取得所有选中的项，可以循环遍历选项集合，然后测试每个选项的selected 属性。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSelectedOptions</span>(<span class="params">selectbox</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">	<span class="keyword">var</span> option = <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = selectbox.options.length; i &lt; len; i++) &#123;</span><br><span class="line">		option = selectbox.options[i];</span><br><span class="line">		<span class="keyword">if</span> (option.selected) &#123;</span><br><span class="line">			result.push(option);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>添加选项</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> newOption = <span class="keyword">new</span> Option(<span class="string">"Option text"</span>, <span class="string">"Option value"</span>);</span><br><span class="line">selectbox.appendChild(newOption); <span class="comment">//在IE8 及之前版本中有问题</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newOption = <span class="keyword">new</span> Option(<span class="string">"Option text"</span>, <span class="string">"Option value"</span>);</span><br><span class="line">selectbox.appendChild(newOption); <span class="comment">//在IE8 及之前版本中有问题</span></span><br></pre></td></tr></table></figure>
<ul>
<li>移除选项</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">selectbox.removeChild(selectbox.options[<span class="number">0</span>]); <span class="comment">//移除第一个选项</span></span><br><span class="line">selectbox.remove(<span class="number">0</span>); <span class="comment">//移除第一个选项</span></span><br></pre></td></tr></table></figure>
<ul>
<li>移动选项</li>
</ul>
<p>可以使用下列代码将选择框中的选项向后移动一个位置。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> optionToMove = selectbox.options[<span class="number">1</span>];</span><br><span class="line">selectbox.insertBefore(optionToMove, selectbox.options[optionToMove.index+<span class="number">2</span>]);</span><br></pre></td></tr></table></figure></p>
<h5 id="【14-4-序列化表单】-见P436"><a href="#【14-4-序列化表单】-见P436" class="headerlink" title="【14.4 序列化表单】 见P436"></a>【14.4 序列化表单】 见P436</h5><h5 id="【14-5-富文本编辑】"><a href="#【14-5-富文本编辑】" class="headerlink" title="【14.5 富文本编辑】"></a>【14.5 富文本编辑】</h5><p>就是在页面中嵌入一个包含空HTML页面的iframe。通过设置designMode属性，这个空白的HTML页面可以被编辑，而编辑对象则是该页面<code>&lt;body&gt;</code>元素的HTML 代码。designMode 属性有两个可能的值：”off”（默认值）和”on”。在设置为”on”时，整个文档都会变得可以编辑</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;iframe name=<span class="string">"richedit"</span> style=<span class="string">"height:100px;width:100px;"</span> src=<span class="string">"blank.htm"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span></span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">"load"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	frames[<span class="string">"richedit"</span>].document.designMode = <span class="string">"on"</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>要让它可以编辑，必须要将designMode 设置为”on”，但只有在页面完全加载之后才能设置这个属性。</p>
<ul>
<li>使用contenteditable属性</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"editable"</span> <span class="attr">id</span>=<span class="string">"richedit"</span> <span class="attr">contenteditable</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样，元素中包含的任何文本内容就都可以编辑了，就好像这个元素变成了<code>&lt;textarea&gt;</code>元素一样。<br>通过在这个元素上设置contenteditable属性，也能打开或关闭编辑模式。contenteditable属性有三个可能的值：”true”表示打开、”false”表示关闭，”inherit”表示从父元素那里继承（因为可以在contenteditable 元素中创建或删除元素）。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"richedit"</span>);</span><br><span class="line">div.contentEditable = <span class="string">"true"</span>;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>操作富文本</li>
</ul>
<p>可以为document.execCommand()方法传递3 个参数：<br>要执行的命令名称、表示浏览器是否应该为当前命令提供用户界面的一个布尔值和执行命令必须的一个<br>值（如果不需要值，则传递null）。为了确保跨浏览器的兼容性，第二个参数应该始终设置为false，<br>因为Firefox 会在该参数为true 时抛出错误。<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//转换粗体文本</span><br><span class="line">frames["richedit"].document.execCommand("bold", false, null);</span><br></pre></td></tr></table></figure></p>
<p>同样的方法也适用于页面中contenteditable 属性为”true”的区块，只要把对框架的引用替换<br>成当前窗口的document 对象即可。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//转换粗体文本</span></span><br><span class="line"><span class="built_in">document</span>.execCommand(<span class="string">"bold"</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，虽然所有浏览器都支持这些命令，但这些命令所产生的HTML 仍然有很大不同。<br>例如，执行bold 命令时，IE 和Opera 会使用<code>&lt;strong&gt;</code>标签包围文本，Safari 和Chrome 使用<code>&lt;b&gt;</code>标签</p>
<ul>
<li>富文本选区</li>
</ul>
<p>在富文本编辑器中，使用框架（iframe）的getSelection()方法，可以确定实际选择的文本。<br>这个方法是window 对象和document 对象的属性，调用它会返回一个表示当前选择文本的Selection<br>对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> selection = frames[<span class="string">"richedit"</span>].getSelection();</span><br><span class="line"><span class="comment">//取得选择的文本</span></span><br><span class="line"><span class="keyword">var</span> selectedText = selection.toString();</span><br><span class="line"><span class="comment">//取得代表选区的范围</span></span><br><span class="line"><span class="keyword">var</span> range = selection.getRangeAt(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//突出显示选择的文本</span></span><br><span class="line"><span class="keyword">var</span> span = frames[<span class="string">"richedit"</span>].document.createElement(<span class="string">"span"</span>);</span><br><span class="line">span.style.backgroundColor = <span class="string">"yellow"</span>;</span><br><span class="line">range.surroundContents(span);</span><br></pre></td></tr></table></figure>
<p>以上代码会为富文本编辑器中被选择的文本添加黄色的背景。这里使用了默认选区中的DOM 范围，<br>通过surroundContents()方法将选区添加到了带有黄色背景的<code>&lt;span&gt;</code>元素中。IE8及更早的版本不支持DOM范围，但我们可以通过它支持的selection对象操作选择的文本。IE中的selection对象是document 的属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IE8中取得富文本编辑器中选择的文本</span></span><br><span class="line"><span class="keyword">var</span> range = frames[<span class="string">"richedit"</span>].document.selection.createRange();</span><br><span class="line"><span class="keyword">var</span> selectedText = range.text;</span><br></pre></td></tr></table></figure>
<ul>
<li>表单与富文本</li>
</ul>
<p>富文本编辑器并不属于表<br>单。换句话说，富文本编辑器中的HTML 不会被自动提交给服务器，而需要我们手工来提取并提交<br>HTML。为此，通常可以添加一个隐藏的表单字段，让它的值等于从iframe 中提取出的HTML。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">EventUtil.addHandler(form, <span class="string">"submit"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">	event = EventUtil.getEvent(event);</span><br><span class="line">	<span class="keyword">var</span> target = EventUtil.getTarget(event);</span><br><span class="line">	target.elements[<span class="string">"comments"</span>].value = frames[<span class="string">"richedit"</span>].document.body.innerHTML;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>对于contenteditable元素，也可以执行类似操作。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">EventUtil.addHandler(form, <span class="string">"submit"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">	event = EventUtil.getEvent(event);</span><br><span class="line">	<span class="keyword">var</span> target = EventUtil.getTarget(event);</span><br><span class="line">	target.elements[<span class="string">"comments"</span>].value =</span><br><span class="line">		<span class="built_in">document</span>.getElementById(<span class="string">"richedit"</span>).innerHTML;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="十五、使用Canvas绘图"><a href="#十五、使用Canvas绘图" class="headerlink" title="十五、使用Canvas绘图"></a>十五、使用Canvas绘图</h4><hr>
<p>P463</p>
<p>（更新中……）</p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/note/">note</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/js/">js</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://yoomin1106.github.io/2014/03/14/note/Professional_JavaScript_for_WEb_Developers_Note/" data-title="Javascript高级程序设计笔记 | matt&#39;s blog" data-tsina="null" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2014/03/14/note/javascript_W3SCHOOL笔记/" title="javascript_W3SCHOOL笔记">
  <strong>上一篇：</strong><br/>
  <span>
  javascript_W3SCHOOL笔记</span>
</a>
</div>


<div class="next">
<a href="/2014/03/14/note/jquery/"  title="李炎恢jquery视频教程笔记">
 <strong>下一篇：</strong><br/> 
 <span>李炎恢jquery视频教程笔记
</span>
</a>
</div>

</nav>

	

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#一、简介"><span class="toc-number">1.</span> <span class="toc-text">一、简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二、在HTML中使用javascript"><span class="toc-number">2.</span> <span class="toc-text">二、在HTML中使用javascript</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#【script】"><span class="toc-number">2.1.</span> <span class="toc-text">【script】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【文档模式】"><span class="toc-number">2.2.</span> <span class="toc-text">【文档模式】</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#三、基本概念"><span class="toc-number">3.</span> <span class="toc-text">三、基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#【语法】"><span class="toc-number">3.1.</span> <span class="toc-text">【语法】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【变量】"><span class="toc-number">3.2.</span> <span class="toc-text">【变量】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【数据类型】"><span class="toc-number">3.3.</span> <span class="toc-text">【数据类型】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【函数】"><span class="toc-number">3.4.</span> <span class="toc-text">【函数】</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#四、变量、作用域和内存问题"><span class="toc-number">4.</span> <span class="toc-text">四、变量、作用域和内存问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#【4-1基本类型和引用类型的值】"><span class="toc-number">4.1.</span> <span class="toc-text">【4.1基本类型和引用类型的值】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【4-2执行环境及作用域】"><span class="toc-number">4.2.</span> <span class="toc-text">【4.2执行环境及作用域】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【4-3垃圾收集】"><span class="toc-number">4.3.</span> <span class="toc-text">【4.3垃圾收集】</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#五、引用类型"><span class="toc-number">5.</span> <span class="toc-text">五、引用类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#【5-1-Object类型】"><span class="toc-number">5.1.</span> <span class="toc-text">【5.1 Object类型】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【5-2-Array类型】"><span class="toc-number">5.2.</span> <span class="toc-text">【5.2 Array类型】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【5-3-Date类型】"><span class="toc-number">5.3.</span> <span class="toc-text">【5.3 Date类型】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【5-4-RegExp类型】？？？？？？？？？？？？"><span class="toc-number">5.4.</span> <span class="toc-text">【5.4 RegExp类型】？？？？？？？？？？？？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【5-5-Function类型】"><span class="toc-number">5.5.</span> <span class="toc-text">【5.5 Function类型】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【5-6-基本包装类型】"><span class="toc-number">5.6.</span> <span class="toc-text">【5.6 基本包装类型】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【单体内置对象】"><span class="toc-number">5.7.</span> <span class="toc-text">【单体内置对象】</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#六、面向对象的程序设计"><span class="toc-number">6.</span> <span class="toc-text">六、面向对象的程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#【理解对象】"><span class="toc-number">6.1.</span> <span class="toc-text">【理解对象】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【6-2-创建对象】"><span class="toc-number">6.2.</span> <span class="toc-text">【6.2 创建对象】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【6-3-继承】"><span class="toc-number">6.3.</span> <span class="toc-text">【6.3 继承】</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#七、函数表达式"><span class="toc-number">7.</span> <span class="toc-text">七、函数表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#【7-1递归】"><span class="toc-number">7.1.</span> <span class="toc-text">【7.1递归】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【7-2闭包】"><span class="toc-number">7.2.</span> <span class="toc-text">【7.2闭包】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【7-3模仿块级作用域】"><span class="toc-number">7.3.</span> <span class="toc-text">【7.3模仿块级作用域】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【7-4私有变量】"><span class="toc-number">7.4.</span> <span class="toc-text">【7.4私有变量】</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#八、BOM"><span class="toc-number">8.</span> <span class="toc-text">八、BOM</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#【8-1-window对象】"><span class="toc-number">8.1.</span> <span class="toc-text">【8.1 window对象】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-2-location对象】"><span class="toc-number">8.2.</span> <span class="toc-text">8.2 location对象】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【8-3-navigation对象】"><span class="toc-number">8.3.</span> <span class="toc-text">【8.3 navigation对象】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【8-4screen对象】"><span class="toc-number">8.4.</span> <span class="toc-text">【8.4screen对象】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【8-5-history对象】"><span class="toc-number">8.5.</span> <span class="toc-text">【8.5 history对象】</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#九、客户端检测"><span class="toc-number">9.</span> <span class="toc-text">九、客户端检测</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#【9-1-能力检测】"><span class="toc-number">9.1.</span> <span class="toc-text">【9.1 能力检测】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【9-2-怪僻检测】"><span class="toc-number">9.2.</span> <span class="toc-text">【9.2 怪僻检测】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【9-3-用户代理检测】"><span class="toc-number">9.3.</span> <span class="toc-text">【9.3 用户代理检测】</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#十、DOM"><span class="toc-number">10.</span> <span class="toc-text">十、DOM</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#【10-1-节点层次】"><span class="toc-number">10.1.</span> <span class="toc-text">【10.1 节点层次】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【10-2-DOM操作技术】"><span class="toc-number">10.2.</span> <span class="toc-text">【10.2 DOM操作技术】</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#十一、DOM扩展"><span class="toc-number">11.</span> <span class="toc-text">十一、DOM扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#【11-1-选择符API】"><span class="toc-number">11.1.</span> <span class="toc-text">【11.1 选择符API】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【元素遍历】"><span class="toc-number">11.2.</span> <span class="toc-text">【元素遍历】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【11-3-HTML5】跳过"><span class="toc-number">11.3.</span> <span class="toc-text">【11.3 HTML5】跳过</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【专有扩展】"><span class="toc-number">11.4.</span> <span class="toc-text">【专有扩展】</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#十二、DOM2和DOM3"><span class="toc-number">12.</span> <span class="toc-text">十二、DOM2和DOM3</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#【12-1-DOM变化】"><span class="toc-number">12.1.</span> <span class="toc-text">【12.1 DOM变化】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【12-2-样式】"><span class="toc-number">12.2.</span> <span class="toc-text">【12.2 样式】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【12-3-遍历、12-3-范围】暂跳过"><span class="toc-number">12.3.</span> <span class="toc-text">【12.3 遍历、12.3 范围】暂跳过</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#十三、事件"><span class="toc-number">13.</span> <span class="toc-text">十三、事件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#【13-1-事件流】"><span class="toc-number">13.1.</span> <span class="toc-text">【13.1 事件流】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【13-2-事件处理程序】"><span class="toc-number">13.2.</span> <span class="toc-text">【13.2 事件处理程序】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【13-3-事件对象】"><span class="toc-number">13.3.</span> <span class="toc-text">【13.3 事件对象】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【13-4-事件类型】"><span class="toc-number">13.4.</span> <span class="toc-text">【13.4 事件类型】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【13-5-内存和性能】"><span class="toc-number">13.5.</span> <span class="toc-text">【13.5 内存和性能】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【13-6-模拟事件】"><span class="toc-number">13.6.</span> <span class="toc-text">【13.6 模拟事件】</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#十四、表单脚本"><span class="toc-number">14.</span> <span class="toc-text">十四、表单脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#【14-1-表单基础】"><span class="toc-number">14.1.</span> <span class="toc-text">【14.1 表单基础】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【14-2-文本框脚本】"><span class="toc-number">14.2.</span> <span class="toc-text">【14.2 文本框脚本】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【14-3-选择框脚本】"><span class="toc-number">14.3.</span> <span class="toc-text">【14.3 选择框脚本】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【14-4-序列化表单】-见P436"><span class="toc-number">14.4.</span> <span class="toc-text">【14.4 序列化表单】 见P436</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#【14-5-富文本编辑】"><span class="toc-number">14.5.</span> <span class="toc-text">【14.5 富文本编辑】</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#十五、使用Canvas绘图"><span class="toc-number">15.</span> <span class="toc-text">十五、使用Canvas绘图</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  


  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/html-css/" title="html/css">html/css<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/note/" title="note">note<sup>7</sup></a></li>
		  
		
		  
			<li><a href="/categories/tools/" title="tools">tools<sup>3</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/js/" title="js">js<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/jquery/" title="jquery">jquery<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/css3/" title="css3">css3<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/angular/" title="angular">angular<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/sass/" title="sass">sass<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/css/" title="css">css<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/前端工具/" title="前端工具">前端工具<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/gulp/" title="gulp">gulp<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/调试/" title="调试">调试<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/webview/" title="webview">webview<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/X5/" title="X5">X5<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="http://www.cnblogs.com/yoomin" target="_blank" title="matt&#39;s blog">matt&#39;s blog</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">新浪微博</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=null&verifier=&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hi! This is matt. <br/>
			</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2016 
		
		<a href="/about" target="_blank" title="Matt.Wu">Matt.Wu</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>









<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
